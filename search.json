[{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://columbia-prime.github.io/pcpr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"pcp-modeling-overview","dir":"Articles","previous_headings":"Preliminaries","what":"PCP modeling overview","title":"Quick start: applying PCP to a simulated environmental mixture","text":"PCP algorithms model observed exposure matrix DD sum three underlying ground-truth matrices: Dn×pmixture=L0low-rank+S0sparse+Z0noise\\underset{\\text{mixture}}{D_{n \\times p}} = \\underset{\\text{low-rank}}{L_0} + \\underset{\\text{sparse}}{S_0} + \\underset{\\text{noise}}{Z_0} low-rank matrix L0L_0 encoding consistent patterns exposure, sparse matrix S0S_0 isolating unique outlying exposure events (explained consistent exposure patterns), dense noise Z0Z_0. matrices dimension n×pn \\times p, nn number observations (e.g. study participants measurement dates) pp number exposures (e.g. chemical /non-chemical stressors). Beyond mixtures model, main assumption made PCP Z0∼N(μ,σ2)Z_0 \\sim N(\\mu, \\sigma^2) consists ..d. Gaussian noise corrupting entry overall exposure matrix DD. models pcpr seek decompose observed data matrix D estimated low-rank sparse components L S use downstream environmental health analyses.","code":""},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"extensions-for-environmental-health-data","dir":"Articles","previous_headings":"Preliminaries","what":"Extensions for environmental health data","title":"Quick start: applying PCP to a simulated environmental mixture","text":"functions pcpr outfitted three environmental health (EH)-specific extensions, making pcpr particularly powerful EH research: Missing value functionality: PCP able recover NA values observed mixture matrix, often outperforming traditional imputation techniques. Leveraging potential limit detection (LOD) information: equipped LOD information, PCP treats estimations values known LOD equally valid approximations fall 0 LOD. PCP LOD data often outperforms PCA imputed LOD2\\frac{LOD}{\\sqrt{2}}. Non-negativity constraint estimated L matrix: desired, PCP can enforce values estimated low-rank matrix L ≥0\\geq 0, better modeling real world mixtures data.","code":""},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"simulated-environmental-mixture-example","dir":"Articles","previous_headings":"","what":"Simulated environmental mixture example","title":"Quick start: applying PCP to a simulated environmental mixture","text":"start loading attaching pcpr package current R session.","code":"library(pcpr)"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"simulating-data","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"Simulating data","title":"Quick start: applying PCP to a simulated environmental mixture","text":"sim_data() function lets users generate simple mixtures models quick experimentation. Let’s use simulate noisy environmental mixture comprised 100 observations 10 chemicals, three underlying chemical exposure patterns (rank r=3r = 3), extreme outlying exposure events along diagonal matrix, dense Gaussian noise corrupting measurements matrix: rank matrix number linearly independent columns rows matrix governing structure data. can intuitively thought number inherent latent patterns data. matrix_rank() function estimates rank given matrix counting number nonzero singular values governing matrix: can see L_0 3 underlying patterns. obscured observed, full-rank mixture matrix D, since S_0 Z components corrupting underlying structure provided L_0. mixtures data often incomplete practice, let’s corrupt random 5% values missing NA corrupt_mat_randomly() function: D_tilde matrix represents observed, messy mixtures model, suffering incomplete NA observations. moment run PCP model D_tilde directly. D_tilde_imputed matrix imputes NA values 0, allowing us call functions support missing NA values.","code":"library(pcpr)  data <- sim_data(   n = 100, p = 10, r = 3,   sparse_nonzero_idxs = seq(1, 1000, 101),   sigma = 0.05 ) D <- data$D L_0 <- data$L S_0 <- data$S Z_0 <- data$Z matrix_rank(L_0) #> [1] 3 matrix_rank(D) #> [1] 10 corrupted_data <- corrupt_mat_randomly(D, perc = 0.05) D_tilde <- corrupted_data$D_tilde D_tilde_imputed <- D_tilde D_tilde_imputed[is.na(D_tilde)] <- 0"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"pcp-model-selection","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"PCP model selection","title":"Quick start: applying PCP to a simulated environmental mixture","text":"two PCP algorithms shipped pcpr: convex root_pcp() [Zhang et al. (2021)] non-convex rrmc() [Cherapanamjeri et al. (2017)]. figure model best data, let’s inspect singular values observed mixture using sing() method:  rrmc() best suited data characterized slowly decaying singular values, indicative complex underlying patterns relatively large degree noise. EH data can described way. root_pcp() best data characterized rapidly decaying singular values, indicative well-defined latent patterns. simple example like , PCP models perfectly suitable. use rrmc(), model environmental health researchers likely employ frequently.","code":"singular_values <- sing(D_tilde_imputed) plot(singular_values, type = \"b\")"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"tuning-pcp-parameters-via-grid-search","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"Tuning PCP parameters via grid search","title":"Quick start: applying PCP to a simulated environmental mixture","text":"estimate low-rank sparse matrices, rrmc() needs given maximum rank r regularization parameter eta. determine optimal values r eta, conduct brief grid search using grid_search_cv() function. grid search , examine models ranks 1 5 values eta near default, calculated get_pcp_defaults(). rrmc() approach PCP uses iterative rank-based procedure recover L S, meaning first constructs rank 1 model iteratively builds specified rank r solution. , grid search grid_search_cv(), pass etas grid argument searching send r = 5 constant parameter common models search. Since length(etas) = 6 r = 5, grid searching 30 different PCP models. num_runs argument grid_search_cv() determines many (random) tests performed unique model setting. default, num_runs = 100, grid search tunes r eta measuring performance 300 different PCP models. Inspecting summary_stats table output grid search provides mean aggregated statistics 30 distinct parameter settings tested. grid search correctly identified rank 3 solution best (lowest relative error rate). corresponding eta = 0.224.","code":"eta_0 <- get_pcp_defaults(D_tilde)$eta cat(paste(\"Default eta value: \", eta_0)) #> Default eta value:  0.0447213595499958 etas <- data.frame(\"eta\" = sort(c(0.1 * eta_0, eta_0 * seq(1, 10, 2)))) gs <- grid_search_cv(D_tilde, pcp_fn = rrmc, grid = etas, r = 5) #>  #> Initializing gridsearch... #> The completed gridsearch will NOT be saved to any files, but simply returned. #> Beginning parallel gridsearch using 4 cores and a multisession strategy... #> Start time: 2025-03-20 01:40:46.064879 #>  #> Gridsearch completed at time: 2025-03-20 01:41:47.426841 #> Metrics calculations complete. r_star <- gs$summary_stats$r[1] eta_star <- round(gs$summary_stats$eta[1], 3) head(gs$summary_stats) #> # A tibble: 6 × 7 #>     eta     r rel_err L_rank S_sparsity iterations run_error_perc #>   <dbl> <int>   <dbl>  <dbl>      <dbl>      <dbl> <chr>          #> 1 0.224     3   0.135   3          98.9        NaN 0%             #> 2 0.313     3   0.137   3          99.0        NaN 0%             #> 3 0.134     3   0.143   3          31.8        NaN 0%             #> 4 0.134     4   0.143   3.03       30.8        NaN 0%             #> 5 0.134     5   0.143   3.03       30.8        NaN 0%             #> 6 0.224     4   0.155   4          99.0        NaN 0%"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"running-pcp","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"Running PCP","title":"Quick start: applying PCP to a simulated environmental mixture","text":"Now can run PCP model: Let’s briefly inspect PCP’s estimate sparse matrix S, fix values “practically” zero using hard_threshold() function. histogram shows majority entries S -0.2 0.2, call values “practically” zero, rest true outlying exposure events.","code":"pcp_model <- rrmc(D_tilde, r = r_star, eta = eta_star) hist(pcp_model$S) pcp_model$S <- hard_threshold(pcp_model$S, thresh = 0.2)"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"benchmarking-with-pca","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"Benchmarking with PCA","title":"Quick start: applying PCP to a simulated environmental mixture","text":"evaluating PCP model, let’s see well traditional method Principal Compoenents Analysis (PCA) can recover L_0, provide benchmark comparison. proj_rank_r() function (project matrix rank r) approximates input matrix low-rank using rank-r truncated SVD, way PCA approximates low-rank matrix. Normally, researcher need determine r subjectively. give PCA advantage sharing PCP’s discovery grid search solution rank 3:","code":"L_pca <- proj_rank_r(D_tilde_imputed, r = r_star)"},{"path":"https://columbia-prime.github.io/pcpr/articles/quickstart-sim-example.html","id":"evaluating-pcp-against-the-ground-truth","dir":"Articles","previous_headings":"Simulated environmental mixture example","what":"Evaluating PCP against the ground truth","title":"Quick start: applying PCP to a simulated environmental mixture","text":"Finally, let’s see recovering L_0 S_0. examine relative error model’s estimates simulated ground truth matrices. use Frobenius norm calculate relative errors matrices: PCP outperformed PCA quite bit! PCP’s relative recovery error L_0 matrix stood 3.34%, compared observed relative error 29.44% PCA’s relative error 23.4%. PCP’s sparse matrix estimate ground truth S_0 5.92%. can now pair estimated L matrix matrix factorization method choice (e.g. factor analysis non-negative matrix factorization, NMF) extract latent chemical exposure patterns. patterns, along isolated outlying exposure events S, can incorporated outcomes interest downstream epidemiological analyses.","code":"data.frame(   \"Obs_rel_err\" = norm(L_0 - D_tilde_imputed, \"F\") / norm(L_0, \"F\"),   \"PCA_L_rel_err\" = norm(L_0 - L_pca, \"F\") / norm(L_0, \"F\"),   \"PCP_L_rel_err\" = norm(L_0 - pcp_model$L, \"F\") / norm(L_0, \"F\"),   \"PCP_S_rel_err\" = norm(S_0 - pcp_model$S, \"F\") / norm(S_0, \"F\"),   \"PCP_L_rank\" = matrix_rank(pcp_model$L) ) #>   Obs_rel_err PCA_L_rel_err PCP_L_rel_err PCP_S_rel_err PCP_L_rank #> 1   0.2944351     0.2340244    0.03337159    0.05924514          3"},{"path":"https://columbia-prime.github.io/pcpr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lawrence G. Chillrud. Author, maintainer. Jaime Benavides. Author. Elizabeth . Gibson. Author. Junhui Zhang. Author. Jingkai Yan. Author. John N. Wright. Author. Jeff Goldsmith. Author. Marianthi-Anna Kioumourtzoglou. Author.","code":""},{"path":"https://columbia-prime.github.io/pcpr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chillrud L, Benavides J, Gibson E, Zhang J, Yan J, Wright J, Goldsmith J, Kioumourtzoglou M (2025). pcpr: Principal Component Pursuit Environmental Epidemiology. R package version 1.0.0, https://columbia-prime.github.io/pcpr/, https://github.com/Columbia-PRIME/pcpr.","code":"@Manual{,   title = {pcpr: Principal Component Pursuit for Environmental Epidemiology},   author = {Lawrence G. Chillrud and Jaime Benavides and Elizabeth A. Gibson and Junhui Zhang and Jingkai Yan and John N. Wright and Jeff Goldsmith and Marianthi-Anna Kioumourtzoglou},   year = {2025},   note = {R package version 1.0.0, https://columbia-prime.github.io/pcpr/},   url = {https://github.com/Columbia-PRIME/pcpr}, }"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"pcpr","dir":"","previous_headings":"","what":"Principal Component Pursuit for Environmental Epidemiology","title":"Principal Component Pursuit for Environmental Epidemiology","text":"R package pcpr implements Principal Component Pursuit (PCP), robust dimensionality reduction technique, pattern recognition tailored environmental health data. statistical methodology computational details provided Gibson et al. (2022).","code":""},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Principal Component Pursuit for Environmental Epidemiology","text":"can install development version pcpr GitHub :","code":"# install.packages(\"pak\") pak::pak(\"Columbia-PRIME/pcpr\")"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"modeling-overview","dir":"","previous_headings":"","what":"Modeling overview","title":"Principal Component Pursuit for Environmental Epidemiology","text":"PCP algorithms model observed exposure matrix DD sum three underlying ground-truth matrices:  low-rank matrix L0L_0 encoding consistent patterns exposure, sparse matrix S0S_0 isolating unique outlying exposure events (explained consistent exposure patterns), dense noise Z0Z_0. matrices dimension n×pn \\times p, nn number observations (e.g. study participants measurement dates) pp number exposures (e.g. chemical /non-chemical stressors). Beyond mixtures model, main assumption made PCP Z0∼𝒩(μ,σ2)Z_0 \\sim \\mathcal{N}(\\mu, \\sigma^2) consists ..d. Gaussian noise corrupting entry overall exposure matrix DD. models pcpr seek decompose observed data matrix D estimated low-rank sparse components L S use downstream environmental health analyses. functions pcpr outfitted three environmental health (EH)-specific extensions making pcpr particularly powerful EH research: Missing value functionality Leveraging potential limit detection (LOD) information Non-negativity constraint estimated L matrix","code":""},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Principal Component Pursuit for Environmental Epidemiology","text":"pcpr supplies functions needed incorporate PCP environmental health analyses. run brief example, using pcpr simulate environmental mixture recover mixture’s underlying consistent patterns sparse outliers.","code":""},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"simulating-data","dir":"","previous_headings":"Usage","what":"Simulating data","title":"Principal Component Pursuit for Environmental Epidemiology","text":"sim_data() function lets users generate simple mixtures models quick experimentation. Let’s use simulate noisy environmental mixture comprised 100 observations 10 chemicals, three underlying chemical exposure patterns (rank r=3r = 3), extreme outlying exposure events along diagonal matrix, dense Gaussian noise corrupting measurements matrix: can see L_0 3 underlying patterns using matrix_rank() function: mixtures data often incomplete practice, let’s simulate random 5% values missing NA corrupt_mat_randomly() function: D_tilde matrix represents observed, messy mixtures model, suffering incomplete NA observations. moment run PCP model D_tilde directly. D_tilde_0fill matrix imputes NA values 0, allowing us call functions support missing NA values.","code":"library(pcpr)  data <- sim_data(   n = 100, p = 10, r = 3,   sparse_nonzero_idxs = seq(1, 1000, 101),   sigma = 0.05 ) D <- data$D L_0 <- data$L S_0 <- data$S Z_0 <- data$Z matrix_rank(L_0) #> [1] 3 corrupted_data <- corrupt_mat_randomly(D, perc = 0.05) D_tilde <- corrupted_data$D_tilde D_tilde_0fill <- D_tilde D_tilde_0fill[is.na(D_tilde)] <- 0"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"pcp-model-selection","dir":"","previous_headings":"Usage","what":"PCP model selection","title":"Principal Component Pursuit for Environmental Epidemiology","text":"two PCP algorithms shipped pcpr: convex root_pcp() [Zhang et al. (2021)] non-convex rrmc() [Cherapanamjeri et al. (2017)]. figure model best data, let’s inspect singular values observed mixture using sing() method:  rrmc() best suited data characterized slowly decaying singular values, indicative complex underlying patterns. EH data can described way. root_pcp() best data characterized rapidly decaying singular values, indicative well-defined latent patterns. simple example like , PCP models perfectly suitable. use rrmc(), model environmental health researchers likely employ frequently.","code":"plot(sing(D_tilde_0fill), type = \"b\", main = \"Singular values of the observed mixture\")"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"tuning-pcp-parameters-via-grid-search","dir":"","previous_headings":"Usage","what":"Tuning PCP parameters via grid search","title":"Principal Component Pursuit for Environmental Epidemiology","text":"estimate low-rank sparse matrices, rrmc() needs given maximum rank r regularization parameter eta. determine optimal values r eta, conduct brief grid search using grid_search_cv() function. grid search , examine models ranks 1 5 values eta near default, calculated get_pcp_defaults(). rrmc() approach PCP uses iterative rank-based procedure recover L S, meaning first constructs rank 1 model iteratively builds specified rank r solution. , grid search grid_search_cv(), pass etas grid argument searching send r = 5 constant parameter common models search. Since length(etas) = 6 r = 5, grid searching 30 different PCP models. num_runs argument grid_search_cv() determines many (random) tests performed unique model setting. default, num_runs = 100, grid search tunes r eta measuring performance 300 different PCP models. Inspecting summary_stats table output grid search provides mean aggregated statistics 30 distinct parameter settings tested. grid search correctly identified rank 3 solution best (lowest relative error rate). corresponding eta = 0.224.","code":"eta_0 <- get_pcp_defaults(D_tilde)$eta cat(paste(\"Default eta value: \", eta_0)) #> Default eta value:  0.0447213595499958 etas <- data.frame(\"eta\" = sort(c(0.1 * eta_0, eta_0 * seq(1, 10, 2)))) gs <- grid_search_cv(D_tilde, pcp_fn = rrmc, grid = etas, r = 5) #>  #> Initializing gridsearch... #> The completed gridsearch will NOT be saved to any files, but simply returned. #> Beginning parallel gridsearch using 16 cores and a multisession strategy... #> Start time: 2025-03-19 20:38:29.869495 #>  #> Gridsearch completed at time: 2025-03-19 20:38:39.14417 #> Metrics calculations complete. r_star <- gs$summary_stats$r[1] eta_star <- round(gs$summary_stats$eta[1], 3) head(gs$summary_stats) #> # A tibble: 6 × 7 #>     eta     r rel_err L_rank S_sparsity iterations run_error_perc #>   <dbl> <int>   <dbl>  <dbl>      <dbl>      <dbl> <chr>          #> 1 0.224     3   0.135   3          98.9        NaN 0%             #> 2 0.313     3   0.137   3          99.0        NaN 0%             #> 3 0.134     3   0.143   3          31.8        NaN 0%             #> 4 0.134     4   0.143   3.03       30.8        NaN 0%             #> 5 0.134     5   0.143   3.03       30.8        NaN 0%             #> 6 0.224     4   0.155   4          99.0        NaN 0%"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"running-pcp","dir":"","previous_headings":"Usage","what":"Running PCP","title":"Principal Component Pursuit for Environmental Epidemiology","text":"Now can run PCP model: Let’s briefly inspect PCP’s estimate sparse matrix S, fix values “practically” zero using hard_threshold() function. histogram shows majority entries S -0.2 0.2, call values “practically” zero, rest true outlying exposure events.","code":"pcp_model <- rrmc(D_tilde, r = r_star, eta = eta_star) hist(pcp_model$S) pcp_model$S <- hard_threshold(pcp_model$S, thresh = 0.2)"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"benchmarking-with-pca","dir":"","previous_headings":"Usage","what":"Benchmarking with PCA","title":"Principal Component Pursuit for Environmental Epidemiology","text":"evaluating PCP model, let’s see well traditional method Principal Compoenents Analysis (PCA) can recover L_0, provide benchmark comparison. proj_rank_r() function (project matrix rank r) approximates input matrix low-rank using rank-r truncated SVD, way PCA approximates low-rank matrix. Normally, researcher need determine r subjectively. give PCA advantage sharing PCP’s discovery grid search solution rank 3:","code":"L_pca <- proj_rank_r(D_tilde_0fill, r = r_star)"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"evaluating-pcp-against-the-ground-truth","dir":"","previous_headings":"Usage","what":"Evaluating PCP against the ground truth","title":"Principal Component Pursuit for Environmental Epidemiology","text":"Finally, let’s see recovering L_0 S_0. examine relative error model’s estimates simulated ground truth matrices. use Frobenius norm calculate relative errors matrices: PCP outperformed PCA quite bit! PCP’s relative recovery error L_0 matrix stood 3.34%, compared observed relative error 29.44% PCA’s relative error 23.4%. PCP’s sparse matrix estimate ground truth S_0 5.92%. can now pair estimated L matrix matrix factorization method choice (e.g. factor analysis NMF) extract latent chemical exposure patterns. patterns, along isolated outlying exposure events S, can incorporated outcomes interest downstream epidemiological analyses.","code":"data.frame(   \"Obs_rel_err\" = norm(L_0 - D_tilde_0fill, \"F\") / norm(L_0, \"F\"),   \"PCA_L_rel_err\" = norm(L_0 - L_pca, \"F\") / norm(L_0, \"F\"),   \"PCP_L_rel_err\" = norm(L_0 - pcp_model$L, \"F\") / norm(L_0, \"F\"),   \"PCP_S_rel_err\" = norm(S_0 - pcp_model$S, \"F\") / norm(S_0, \"F\"),   \"PCP_L_rank\" = matrix_rank(pcp_model$L) ) #>   Obs_rel_err PCA_L_rel_err PCP_L_rel_err PCP_S_rel_err PCP_L_rank #> 1   0.2944351     0.2340244    0.03337159    0.05924514          3"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"a-real-world-application","dir":"","previous_headings":"","what":"A real world application","title":"Principal Component Pursuit for Environmental Epidemiology","text":"pcpr package also ships real world air pollution dataset queens consisting fine particulate matter measurements (µg/m^3) 26 PM2.5 chemical species, recorded every three six days 04/04/2001 12/30/2021 courtesy EPA AQS monitoring site Queens, New York City (NYC): can follow along real source apportionment analysis using queens data source apportionment vignette.","code":"queens #> # A tibble: 2,443 × 27 #>    Date            Al   NH4      As     Ba       Br     Cd      Ca      Cl #>    <date>       <dbl> <dbl>   <dbl>  <dbl>    <dbl>  <dbl>   <dbl>   <dbl> #>  1 2001-04-04 NA      1.62  NA      NA     NA       NA     NA      NA      #>  2 2001-04-07  0      2.66   0       0.012  0.00488  0      0.0401  0.0079 #>  3 2001-04-13  0.0094 1.41   0.0016  0.024  0.00211  0.004  0.036   0      #>  4 2001-04-19  0.0104 1.22   0.001   0.006  0.00422  0      0.0543  0.003  #>  5 2001-04-25  0.0172 0.723  0.0024  0.015  0.00117  0      0.0398  0      #>  6 2001-05-01  0.0384 3.48   0.0017  0.041  0.00873  0.001  0.136   0      #>  7 2001-05-04  0.0964 6.22   0.0025  0.039  0.0111   0      0.137   0      #>  8 2001-05-07  0.004  0.233  0.001   0.016  0.00263  0      0.055   0.0054 #>  9 2001-05-10  0.0547 2.04   0.001   0.055  0.00521  0      0.121   0.001  #> 10 2001-05-13  0.0215 0.229  0       0.021  0.00122  0      0.0249  0      #> # ℹ 2,433 more rows #> # ℹ 18 more variables: Cr <dbl>, Cu <dbl>, EC <dbl>, Fe <dbl>, Pb <dbl>, #> #   Mg <dbl>, Mn <dbl>, Ni <dbl>, OC <dbl>, K <dbl>, Se <dbl>, Si <dbl>, #> #   Na <dbl>, S <dbl>, Ti <dbl>, NO3 <dbl>, V <dbl>, Zn <dbl>"},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"pcp-in-environmental-health-studies","dir":"","previous_headings":"","what":"PCP in environmental health studies","title":"Principal Component Pursuit for Environmental Epidemiology","text":"methods pcpr already applied many environmental health studies. Several listed : Tao et al. (2023) apply PCP investigate association source-specific fine particulate matter myocardial infarction hospitalizations NYC. Wu et al. (2024) employ PCP exposome profiling environmental pollutants seminal plasma, uncovering novel associations semen parameters. Benavides et al. (2024) use PCP develop Community Severity Index NYC, measuring barrier effect road infrastructure traffic cities.","code":""},{"path":"https://columbia-prime.github.io/pcpr/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Principal Component Pursuit for Environmental Epidemiology","text":"Gibson, Elizabeth ., Junhui Zhang, Jingkai Yan, Lawrence Chillrud, Jaime Benavides, Yanelli Nunez, Julie B. Herbstman, Jeff Goldsmith, John Wright, Marianthi-Anna Kioumourtzoglou. “Principal component pursuit pattern identification environmental mixtures.” Environmental Health Perspectives 130, . 11 (2022): 117008. [available ] Zhang, Junhui, Jingkai Yan, John Wright. “Square root principal component pursuit: tuning-free noisy robust matrix recovery.” Advances Neural Information Processing Systems 34 (2021): 29464-29475. [available ] Cherapanamjeri, Yeshwanth, Kartik Gupta, Prateek Jain. “Nearly optimal robust matrix completion.” International Conference Machine Learning. PMLR, (2017). [available ] Tao, Rachel H., Lawrence G. Chillrud, Yanelli Nunez, Sebastian T. Rowland, Amelia K. Boehme, Jingkai Yan, Jeff Goldsmith, John Wright, Marianthi-Anna Kioumourtzoglou. “Applying principal component pursuit investigate association source-specific fine particulate matter myocardial infarction hospitalizations New York City.” Environmental Epidemiology 7 (2), (2023). [available ] Wu, Haotian, Vrinda Kalia, Katherine E. Manz, Lawrence Chillrud, Nathalie Hoffmann Dishon, Gabriela L. Jackson, Christian K. Dye, Raoul Orvieto, Adva Aizer, Hagai Levine, Marianthi-Anna Kioumourtzoglou, Kurt D. Pennell, Andrea . Baccarelli, Ronit Machtinger. “Exposome Profiling Environmental Pollutants Seminal Plasma Novel Associations Semen Parameters.” Environmental Science & Technology, 58 (31), (2024): 13594-13604. [available ] Benavides, Jaime, Sabah Usmani, Vijay Kumar, Marianthi-Anna Kioumourtzoglou. “Development community severance index urban areas United States: case study New York City.” Environment International, 185, (2024): 108526. [available ]","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/corrupt_mat_randomly.html","id":null,"dir":"Reference","previous_headings":"","what":"Corrupt given matrix with random missingness — corrupt_mat_randomly","title":"Corrupt given matrix with random missingness — corrupt_mat_randomly","text":"corrupt_mat_randomly() corrupts given data matrix D perc percent entries set missing (set NA). Used grid_search_cv() constructing test matrices PCP models. Can used experimentation PCP models. Note: observed values can corrupted NA. means matrix D already e.g. 20% values missing, corrupt_mat_randomly(D, perc = 0.2) result matrix 40% values missing. e.g. perc = 0.6 passed input D e.g. 10% entries left observed, remaining corruptable entries set NA.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/corrupt_mat_randomly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corrupt given matrix with random missingness — corrupt_mat_randomly","text":"","code":"corrupt_mat_randomly(D, perc, seed = 42)"},{"path":"https://columbia-prime.github.io/pcpr/reference/corrupt_mat_randomly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corrupt given matrix with random missingness — corrupt_mat_randomly","text":"D input data matrix. perc double >= 0 specifying percentage entries D corrupt missing (NA). seed (Optional) integer specifying seed random selection entries D corrupt missing (NA). default, seed = 42.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/corrupt_mat_randomly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corrupt given matrix with random missingness — corrupt_mat_randomly","text":"list containing: D_tilde: original matrix D random perc percent entries set NA. tilde_mask: binary matrix dim(D) specifying locations corrupted entries (1) uncorrupted entries (0).","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/corrupt_mat_randomly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Corrupt given matrix with random missingness — corrupt_mat_randomly","text":"","code":"# Simple example corrupting 20% of a 5x5 matrix D <- matrix(1:25, 5, 5) corrupted_data <- corrupt_mat_randomly(D, perc = 0.2) corrupted_data$D_tilde #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA    6   11   16   21 #> [2,]    2    7   12   NA   22 #> [3,]    3    8   13   18   23 #> [4,]   NA    9   14   19   24 #> [5,]   NA   NA   15   20   25 sum(is.na(corrupted_data$D_tilde)) / prod(dim(corrupted_data$D_tilde)) #> [1] 0.2 # Now corrupting another 20% ontop of the original 20% double_corrupted <- corrupt_mat_randomly(corrupted_data$D_tilde, perc = 0.2) double_corrupted$D_tilde #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA    6   11   16   21 #> [2,]   NA   NA   12   NA   NA #> [3,]    3   NA   13   18   23 #> [4,]   NA    9   NA   19   24 #> [5,]   NA   NA   15   20   25 sum(is.na(double_corrupted$D_tilde)) / prod(dim(double_corrupted$D_tilde)) #> [1] 0.4 # Corrupting the remaining entries by passing in a large value for perc all_corrupted <- corrupt_mat_randomly(double_corrupted$D_tilde, perc = 1) all_corrupted$D_tilde #>      [,1] [,2] [,3] [,4] [,5] #> [1,]   NA   NA   NA   NA   NA #> [2,]   NA   NA   NA   NA   NA #> [3,]   NA   NA   NA   NA   NA #> [4,]   NA   NA   NA   NA   NA #> [5,]   NA   NA   NA   NA   NA"},{"path":"https://columbia-prime.github.io/pcpr/reference/eval_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate parameters — eval_params","title":"Evaluate parameters — eval_params","text":"Given documented parameter settings settings, test matrix test_mat, PCP solution pcp_model, binary mask test_mask, returns statistics pcp_model's performance settings test_mat. internal function needed grid_search_cv(). expected users require access function.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/eval_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate parameters — eval_params","text":"","code":"eval_params(settings, test_mat, pcp_model, test_mask)"},{"path":"https://columbia-prime.github.io/pcpr/reference/eval_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate parameters — eval_params","text":"settings Documented parameter settings associated given pcp_model. test_mat given test matrix test_mask observed (.e. missing). pcp_model output PCP algorithm, either rrmc() root_pcp(). test_mask binary mask indicating entries test_mat comprise test set.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/eval_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate parameters — eval_params","text":"data.frame object PCP's performance statistics.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"get_pcp_defaults() calculates \"default\" PCP parameter settings lambda, mu (used root_pcp()), eta (used rrmc()) given data matrix D. \"default\" values lambda mu offer theoretical guarantees optimal estimation performance. Candès et al. (2011) obtained guarantee lambda, Zhang et al. (2021) obtained result mu. yet proven whether eta enjoys similar properties. practice common find different optimal parameter values tuning parameters grid search. Therefore, recommended use defaults primarily help define reasonable initial parameter search space pass grid_search_cv().","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"","code":"get_pcp_defaults(D)"},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"D input data matrix.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"list containing: lambda: theoretically optimal lambda value used root_pcp(). mu: theoretically optimal mu value used root_pcp(). eta: default eta value used rrmc().","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"the-intuition-behind-pcp-parameters","dir":"Reference","previous_headings":"","what":"The intuition behind PCP parameters","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"root_pcp()'s objective function given : $$\\min_{L, S} ||L||_* + \\lambda ||S||_1 + \\mu ||L + S - D||_F$$ lambda controls sparsity root_pcp()'s output S matrix; larger values lambda penalize non-zero entries S stringently, driving recovery sparser S matrices. Therefore, priori expect outlying events model, might expect grid search recover relatively larger lambda values, vice-versa. mu adjusts root_pcp()'s sensitivity noise; larger values mu penalize errors predicted model observed data (.e. noise), severely. Environmental data subject higher noise levels therefore require root_pcp() model equipped smaller mu values (since higher noise means greater discrepancy observed mixture true underlying low-rank sparse model). virtually noise-free settings (e.g. simulations), larger values mu appropriate. rrmc()'s objective function given : $$\\min_{L, S} I_{rank(L) \\leq r} + \\eta ||S||_0 + ||L + S - D||_F^2$$ eta controls sparsity rrmc()'s output S matrix, just lambda root_pcp(). parameters scaling noise term, eta can thought ratio root_pcp()'s lambda mu: Larger values eta place greater emphasis penalizing non-zero entries S penalizing errors predicted observed data (dense noise Z).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"the-calculation-of-the-default-pcp-parameters","dir":"Reference","previous_headings":"","what":"The calculation of the \"default\" PCP parameters","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"lambda calculated \\(\\lambda = 1 / \\sqrt{\\max(n, p)},\\) \\(n\\) \\(p\\) dimensions input matrix \\(D_{n \\times p}\\) Candès et al. (2011). mu calculated \\(\\mu = \\sqrt{\\frac{\\min(n, p)}{2}},\\) \\(n\\) \\(p\\) [Zhang et al. (2021)]. eta simply \\(\\eta = \\frac{\\lambda}{\\mu}\\).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"Candès, Emmanuel J., Xiaodong Li, Yi Ma, John Wright. \"Robust principal component analysis?.\" Journal ACM (JACM) 58, . 3 (2011): 1-37. Zhang, Junhui, Jingkai Yan, John Wright. \"Square root principal component pursuit: tuning-free noisy robust matrix recovery.\" Advances Neural Information Processing Systems 34 (2021): 29464-29475. [available ]","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/get_pcp_defaults.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve default PCP parameter settings for given matrix — get_pcp_defaults","text":"","code":"# Examine the queens PM2.5 data queens #> # A tibble: 2,443 × 27 #>    Date            Al   NH4      As     Ba       Br     Cd      Ca      Cl #>    <date>       <dbl> <dbl>   <dbl>  <dbl>    <dbl>  <dbl>   <dbl>   <dbl> #>  1 2001-04-04 NA      1.62  NA      NA     NA       NA     NA      NA      #>  2 2001-04-07  0      2.66   0       0.012  0.00488  0      0.0401  0.0079 #>  3 2001-04-13  0.0094 1.41   0.0016  0.024  0.00211  0.004  0.036   0      #>  4 2001-04-19  0.0104 1.22   0.001   0.006  0.00422  0      0.0543  0.003  #>  5 2001-04-25  0.0172 0.723  0.0024  0.015  0.00117  0      0.0398  0      #>  6 2001-05-01  0.0384 3.48   0.0017  0.041  0.00873  0.001  0.136   0      #>  7 2001-05-04  0.0964 6.22   0.0025  0.039  0.0111   0      0.137   0      #>  8 2001-05-07  0.004  0.233  0.001   0.016  0.00263  0      0.055   0.0054 #>  9 2001-05-10  0.0547 2.04   0.001   0.055  0.00521  0      0.121   0.001  #> 10 2001-05-13  0.0215 0.229  0       0.021  0.00122  0      0.0249  0      #> # ℹ 2,433 more rows #> # ℹ 18 more variables: Cr <dbl>, Cu <dbl>, EC <dbl>, Fe <dbl>, Pb <dbl>, #> #   Mg <dbl>, Mn <dbl>, Ni <dbl>, OC <dbl>, K <dbl>, Se <dbl>, Si <dbl>, #> #   Na <dbl>, S <dbl>, Ti <dbl>, NO3 <dbl>, V <dbl>, Zn <dbl> # Get rid of the Date column D <- queens[, 2:ncol(queens)] # Get default PCP parameters default_params <- get_pcp_defaults(D) # Use default parameters to define parameter search space scaling_factors <- sort(c(10^seq(-2, 4, 1), 2 * 10^seq(-2, 4, 1))) etas_to_grid_search <- default_params$eta * scaling_factors etas_to_grid_search #>  [1] 5.611340e-05 1.122268e-04 5.611340e-04 1.122268e-03 5.611340e-03 #>  [6] 1.122268e-02 5.611340e-02 1.122268e-01 5.611340e-01 1.122268e+00 #> [11] 5.611340e+00 1.122268e+01 5.611340e+01 1.122268e+02"},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated grid search for PCP models — grid_search_cv","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"grid_search_cv() conducts Monte Carlo style cross-validated grid search PCP parameters given data matrix D, PCP function pcp_fn, grid parameter settings search grid. run time grid search can sped using bespoke parallelization settings. See sections details.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"","code":"grid_search_cv(   D,   pcp_fn,   grid,   ...,   scale_fn = NULL,   parallel_strategy = \"multisession\",   num_cores = parallel::detectCores(logical = FALSE),   perc_test = 0.05,   num_runs = 100,   conserve_memory = FALSE,   verbose = TRUE,   save_as = NULL )"},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"D input data matrix (can contain NA values). Note PCP converge much quickly D standardized way (e.g. scaling columns standard deviations, column-wise min-max normalization). pcp_fn PCP function use grid searching. Must either rrmc root_pcp (passed without soft brackets). grid data.frame dimension n p containing n-many settings p-many parameters try. columns grid named parameters function header pcp_fn. example, pcp_fn = root_pcp, names(grid) must set c(\"lambda\", \"mu\") grid searching different settings lambda mu. Likewise pcp_fn = rrmc eta r. ... parameters required pcp_fn specified grid. Importantly, parameters therefore kept constant (involved grid search). best example LOD parameter cases user LOD information PCP leverage. scale_fn (Optional) function used scale input D column. default, scale_fn = NULL, scaling done. parallel_strategy (Optional) parallelization strategy used conducting gridsearch (passed future::plan() function). Must one : \"sequential\", \"multisession\", \"multicore\" \"cluster\". default, parallel_strategy = \"multisession\", parallelizes grid search via sockets separate R sessions. parallel_strategy = \"sequential\" search conducted serial num_cores argument ignored. option parallel_strategy = \"multicore\" supported Windows machines, .Rmd files (must run .R script) parallelizes search much faster \"multisession\" since runs separate forked R processes. option parallel_strategy = \"cluster\" parallelizes using separate R sessions running typically one machines. Support parallel strategies added future release pcpr. recommended use parallel_strategy = \"multicore\" \"multisession\" possible. num_cores (Optional) integer specifying number cores use parallelizing grid search. default, num_cores = parallel::detectCores(logical = F), computes number physical CPUs available machine (see parallel::detectCores()). Ignored parallel_strategy = \"sequential\", must > 1 otherwise. perc_test (Optional) fraction entries D randomly corrupted NA missing values (test set). Can anthing range [0, 1). default, perc_test = 0.05. See Best practices section details. num_runs (Optional) number times test given parameter setting. default, num_runs = 100. See Best practices section details. conserve_memory (Optional) logical indicating care statistics gridsearch therefore like conserve memory running gridsearch. set TRUE, statistics parameters tested returned. default, conserve_memory = FALSE, case additional objects saving outputs runs pcp_fn also returned. verbose (Optional) logical indicating like verbose output displayed (e.g. progress bars). default, verbose = TRUE. save_as (Optional) character containing root file path used save output . Importantly, end file extension, since character used save resulting [save_as].rds [save_as]_README.txt files. default, save_as = NULL, case gridsearch saved file.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"list containing: all_stats: data.frame containing statistics every run comprising grid search. statistics include parameter settings run, along run number (used seed corruption step outlined step 1 Procedure section), relative error run rel_err, rank recovered L matrix L_rank, sparsity recovered S matrix S_sparsity, number iterations PCP took reach convergence (root_pcp() ), error status run_error PCP run (NA error, otherwise character). summary_stats: data.frame containing summary information all_stats. Summary made column-wise averaging results all_stats. L_mats: list containing L matrices returned PCP throughout gridsearch. Therefore, length(L_mats) == nrow(all_stats). Row all_stats corresponds L_mats[[]]. returned conserve_memory = FALSE. S_mats: list containing S matrices returned PCP throughout gridsearch. Therefore, length(S_mats) == nrow(all_stats). Row all_stats corresponds S_mats[[]]. returned conserve_memory = FALSE. test_mats: list length(num_runs) containing corrupted test mats (masks) used throughout gridsearch. Note: all_stats$run[] corresponds test_mats[[]]. returned conserve_memory = FALSE. original_mat: original data matrix D column scaled scale_fn. returned conserve_memory = FALSE. constant_params: copy constant parameters originally passed gridsearch (record keeping).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"the-monte-carlo-style-cross-validation-procedure","dir":"Reference","previous_headings":"","what":"The Monte Carlo style cross-validation procedure","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"hyperparameter setting cross-validated : Randomly corrupting perc_test percent entries D missing (.e. NA values), yielding D_tilde. Done via corrupt_mat_randomly(). Running PCP function pcp_fn D_tilde, yielding estimates L S. Recording relative recovery error L compared input data matrix D values imputed missing corruption step (step 1 ). Mathematically, calculate: \\(||P_{\\Omega^c}(D - L)||_F / ||P_{\\Omega^c}(D)||_F\\), \\(P_{\\Omega^c}\\) selects entries .na(D_tilde) == TRUE. Repeating steps 1-3 total num_runs-many times, \"run\" unique random seed 1 num_runs associated . Performance statistics can calculated \"run\", summarized across runs average model performance statistics.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"best-practices-for-perc-test-and-num-runs","dir":"Reference","previous_headings":"","what":"Best practices for perc_test and num_runs","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"Experimentally, grid search procedure retrieves best performing PCP parameter settings perc_test relatively low, e.g. perc_test = 0.05, 5%, num_runs relatively high, e.g. num_runs = 100. larger perc_test , test set turns matrix completion problem, rather desired matrix decomposition problem. better resemble actual problem PCP faced come inference time, perc_test therefore kept relatively low. Choosing reasonable value num_runs dependent need keep perc_test relatively low. Ideally, large enough num_runs used many () entries D likely eventually tested. Note since test set entries chosen randomly runs 1 num_runs, pathologically worst case scenario, exact test set drawn time. ebst case scenario, different test set obtained run, providing balanced coverage D. Viewed another way, smaller num_runs , results susceptible overfitting relatively selected test sets.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"interpretaion-of-results","dir":"Reference","previous_headings":"","what":"Interpretaion of results","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"grid search conducted, optimal hyperparameters can chosen examining output statistics summary_stats. suggestions interpret summary_stats table: Generally speaking, first thing user want inspect rel_err statistic, capturing relative discrepancy recovered test sets original, observed (yet possibly noisy) values. Lower rel_err means PCP model better able recover held-test set. , general, best parameter settings lowest rel_err. said , important remember statistic taken grain salt: ground truth L matrix exists, rel_err measurement forced rely comparison noisy observed data matrix D estimated low-rank model L. rel_err metric \"apples oranges\" relative error. data priori expected subject high degree noise, may actually better discard parameter settings suspiciously low rel_errs (case solution may hallucinating inaccurate low-rank structure observed noise). grid searches using root_pcp() PCP model, parameters fail converge can discarded. Generally, fewer root_pcp() iterations (num_iter) taken reach convergence portend reliable / stable solution. rare cases, user may need increase root_pcp()'s max_iter argument reach convergence. rrmc() report convergence metadata, optimization scheme runs fixed number iterations. Parameter settings unreasonable sparsity rank measurements can also discarded. , \"unreasonable\" means reported metrics flagrantly contradict prior assumptions, knowledge, work. instance, air pollution datasets contain number extreme exposure events, PCP solutions returning sparse S models 100% sparsity obviously regularized heavily. Solutions lower sparsities preferred. Note reported sparsity rank measurements estimates heavily dependent thresh set sparsity() & matrix_rank() functions. E.g. actual average matrix rank much higher lower threshold better takes account relative scale singular values used. Likewise sparsity estimations. Also, recall given value perc_test artifically sets sparsity floor, since missing entries test set recovered S matrix. E.g. perc_test = 0.05, parameter setting estimated sparsity lower 5%.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/grid_search_cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validated grid search for PCP models — grid_search_cv","text":"","code":"####-------Simple simulated PCP problem-------#### # First we will simulate a simple dataset with the sim_data() function. # The dataset will be a 100x10 matrix comprised of: # 1. A rank-3 component as the ground truth L matrix; # 2. A ground truth sparse component S w/outliers in 1st & last entries; and # 3. A dense Gaussian noise component data <- sim_data() # Normally we would conduct grid search to tune eta. But, to keep the example # short, we will just use best parameters from the below grid search example: if (FALSE) { # \\dontrun{ eta_0 <- get_pcp_defaults(data$D)$eta eta_grid <- data.frame(\"eta\" = sort(c(0.1 * eta_0, eta_0 * seq(1, 10, 2))), \"r\" = 7) gs <- grid_search_cv(data$D, rrmc, eta_grid) dplyr::arrange(gs$summary_stats, rel_err) } # } # The gs found the best rank to be 3, and the best eta to be 0.3 or 0.4, so # we will split the difference and use an eta of 0.35 pcp_model <- rrmc(data$D, r = 3, eta = 0.35) data.frame(   \"Observed_relative_error\" = norm(data$L - data$D, \"F\") / norm(data$L, \"F\"),   \"PCA_error\" = norm(data$L - proj_rank_r(data$D, r = 3), \"F\") / norm(data$L, \"F\"),   \"PCP_L_error\" = norm(data$L - pcp_model$L, \"F\") / norm(data$L, \"F\"),   \"PCP_S_error\" = norm(data$S - pcp_model$S, \"F\") / norm(data$S, \"F\") ) #>   Observed_relative_error  PCA_error PCP_L_error PCP_S_error #> 1              0.07876326 0.04070336  0.03289421  0.05839639 # Results: # The grid search correctly found the rank (3) of the ground truth L matrix! # PCP outperformed PCA in it's recovery of the L matrix (even though we let # PCA \"cheat\" by telling PCA it was looking for a rank 3 solution)! # PCP successfully isolated the outlying event in S!"},{"path":"https://columbia-prime.github.io/pcpr/reference/hard_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Hard-thresholding operator — hard_threshold","title":"Hard-thresholding operator — hard_threshold","text":"hard_threshold() implements hard-thresholding operator given matrix D, making D sparser: elements D whose absolute value less given threshold thresh set 0, .e. \\(D[|D| < thresh] = 0\\). used non-convex PCP function rrmc() provide non-convex replacement prox_l1() method used convex PCP function root_pcp(). used iteratively model sparse S matrix help adaptive threshold (thresh changes course optimization).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/hard_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hard-thresholding operator — hard_threshold","text":"","code":"hard_threshold(D, thresh)"},{"path":"https://columbia-prime.github.io/pcpr/reference/hard_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hard-thresholding operator — hard_threshold","text":"D input data matrix. thresh scalar-valued hard-threshold acting D D[, j] = 0 abs(D[, j]) < thresh, D[, j] = D[, j] otherwise.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/hard_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hard-thresholding operator — hard_threshold","text":"hard-thresholded matrix.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/hard_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hard-thresholding operator — hard_threshold","text":"","code":"set.seed(42) D <- matrix(rnorm(25), 5, 5) S <- hard_threshold(D, thresh = 1) D #>            [,1]        [,2]       [,3]       [,4]       [,5] #> [1,]  1.3709584 -0.10612452  1.3048697  0.6359504 -0.3066386 #> [2,] -0.5646982  1.51152200  2.2866454 -0.2842529 -1.7813084 #> [3,]  0.3631284 -0.09465904 -1.3888607 -2.6564554 -0.1719174 #> [4,]  0.6328626  2.01842371 -0.2787888 -2.4404669  1.2146747 #> [5,]  0.4042683 -0.06271410 -0.1333213  1.3201133  1.8951935 S #>          [,1]     [,2]      [,3]      [,4]      [,5] #> [1,] 1.370958 0.000000  1.304870  0.000000  0.000000 #> [2,] 0.000000 1.511522  2.286645  0.000000 -1.781308 #> [3,] 0.000000 0.000000 -1.388861 -2.656455  0.000000 #> [4,] 0.000000 2.018424  0.000000 -2.440467  1.214675 #> [5,] 0.000000 0.000000  0.000000  1.320113  1.895193"},{"path":"https://columbia-prime.github.io/pcpr/reference/loss_lod.html","id":null,"dir":"Reference","previous_headings":"","what":"Loss function for PCP's limit of detection penalty — loss_lod","title":"Loss function for PCP's limit of detection penalty — loss_lod","text":"loss_lod() includes LOD-specific penalty terms compute loss squared error term L + S - D.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/loss_lod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loss function for PCP's limit of detection penalty — loss_lod","text":"","code":"loss_lod(D, X, LOD)"},{"path":"https://columbia-prime.github.io/pcpr/reference/loss_lod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loss function for PCP's limit of detection penalty — loss_lod","text":"D original data matrix. X predicted value L + S current iteration. LOD LOD matrix, dim(LOD) == dim(D).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/loss_lod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loss function for PCP's limit of detection penalty — loss_lod","text":"Scalar value used calculate loss objective function.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/matrix_rank.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate rank of a given matrix — matrix_rank","title":"Estimate rank of a given matrix — matrix_rank","text":"matrix_rank() estimates rank given data matrix D counting number \"practically nonzero\" singular values D. singular value \\(s\\) determined \"practically nonzero\" \\(s \\geq s_max * thresh\\), .e. greater equal maximum singular value D scaled given threshold thresh.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/matrix_rank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate rank of a given matrix — matrix_rank","text":"","code":"matrix_rank(D, thresh = NULL)"},{"path":"https://columbia-prime.github.io/pcpr/reference/matrix_rank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate rank of a given matrix — matrix_rank","text":"D input data matrix. thresh (Optional) double eqn{> 0}, specifying relative threshold \"practically zero\" determined, used calculate rank D. default, thresh = NULL, case threshold set max(dim(D)) * .Machine$double.eps.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/matrix_rank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate rank of a given matrix — matrix_rank","text":"integer representing rank D.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/matrix_rank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate rank of a given matrix — matrix_rank","text":"","code":"data <- sim_data() matrix_rank(data$D) #> [1] 10 matrix_rank(data$L) #> [1] 3"},{"path":"https://columbia-prime.github.io/pcpr/reference/pcpr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"pcpr: Principal Component Pursuit for Environmental Epidemiology — pcpr-package","title":"pcpr: Principal Component Pursuit for Environmental Epidemiology — pcpr-package","text":"Implementation pattern recognition technique Principal Component Pursuit tailored environmental health data, described Gibson et al. (2022) doi:10.1289/EHP10479 .","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/pcpr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"pcpr: Principal Component Pursuit for Environmental Epidemiology — pcpr-package","text":"Maintainer: Lawrence G. Chillrud chili@u.northwestern.edu Authors: Jaime Benavides Elizabeth . Gibson Junhui Zhang Jingkai Yan John N. Wright Jeff Goldsmith Marianthi-Anna Kioumourtzoglou","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/proj_rank_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Project matrix to rank r — proj_rank_r","title":"Project matrix to rank r — proj_rank_r","text":"proj_rank_r() implements best (.e. closest) rank-r approximation input matrix. computed via simple truncated singular value decomposition (SVD), retaining first r leading singular values/vectors D. equivalent solving following optimization problem: \\(min ||X-D||_F s.t. rank(X) <= r\\), X approximated solution D input matrix. proj_rank_r() used iteratively model low-rank L matrix non-convex PCP function rrmc(), providing non-convex replacement prox_nuclear() method used convex PCP function root_pcp(). Intuitively, proj_rank_r() can also thought providing PCA estimate rank-r matrix L observed data D.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/proj_rank_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project matrix to rank r — proj_rank_r","text":"","code":"proj_rank_r(D, r)"},{"path":"https://columbia-prime.github.io/pcpr/reference/proj_rank_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project matrix to rank r — proj_rank_r","text":"D input data matrix. r rank D projected/truncated .","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/proj_rank_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project matrix to rank r — proj_rank_r","text":"best rank-r approximation D via truncated SVD.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/proj_rank_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project matrix to rank r — proj_rank_r","text":"","code":"# Simulating a simple dataset D with the sim_data() function. # The dataset will be a 10x5 matrix comprised of: # 1. A rank-1 component as the ground truth L matrix; and # 2. A dense Gaussian noise component corrupting L, making L full-rank data <- sim_data(10, 5, 1, numeric(), 0.01) # The observed matrix D is full-rank, while L is rank-1: data.frame(\"D_rank\" = matrix_rank(data$D), \"L_rank\" = matrix_rank(data$L)) #>   D_rank L_rank #> 1      5      1 before_proj_err <- norm(data$D - data$L, \"F\") / norm(data$L, \"F\") # Projecting D onto the nearest rank-1 approximation, X, via proj_rank_r() X <- proj_rank_r(data$D, r = 1) after_proj_err <- norm(X - data$L, \"F\") / norm(data$L, \"F\") proj_v_obs_err <- norm(X - data$D, \"F\") / norm(data$D, \"F\") data.frame(   \"Observed_error\" = before_proj_err,   \"Projected_error\" = after_proj_err,   \"Projected_vs_observed_error\" = proj_v_obs_err ) #>   Observed_error Projected_error Projected_vs_observed_error #> 1      0.0283898      0.01435178                  0.02436504"},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_frobenius.html","id":null,"dir":"Reference","previous_headings":"","what":"Proximal gradient method for the Frobenius norm — prox_frobenius","title":"Proximal gradient method for the Frobenius norm — prox_frobenius","text":"prox_frobenius() implements proximal gradient method Frobenius norm. proximal gradient method used solve non-differentiable convex optimization problems. root_pcp(), thresholding minimizes square root sum squared error, error defined Z = D - L - S. internal function needed root_pcp(). expected users require access function.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_frobenius.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proximal gradient method for the Frobenius norm — prox_frobenius","text":"","code":"prox_frobenius(Z, c)"},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_frobenius.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proximal gradient method for the Frobenius norm — prox_frobenius","text":"Z input error/noise matrix, Z = D - L - S. c amount prox Frobenius method penalizes Z.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_frobenius.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proximal gradient method for the Frobenius norm — prox_frobenius","text":"thresholded error/noise matrix.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_l1.html","id":null,"dir":"Reference","previous_headings":"","what":"Proximal gradient method for the L1 norm — prox_l1","title":"Proximal gradient method for the L1 norm — prox_l1","text":"prox_l1() implements proximal gradient method L1 norm. root_pcp(), soft thresholding encourages S matrix sparse. proximal gradient method used solve non-differentiable convex optimization problems. internal function needed root_pcp(). expected users require access function.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_l1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proximal gradient method for the L1 norm — prox_l1","text":"","code":"prox_l1(S, c)"},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_l1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proximal gradient method for the L1 norm — prox_l1","text":"S input sparse matrix. c amount prox L1 method penalizes S.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_l1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proximal gradient method for the L1 norm — prox_l1","text":"thresholded sparse matrix.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_nuclear.html","id":null,"dir":"Reference","previous_headings":"","what":"Proximal gradient method for the nuclear norm — prox_nuclear","title":"Proximal gradient method for the nuclear norm — prox_nuclear","text":"prox_nuclear() implements proximal gradient method nuclear norm. nuclear norm equivalent L2 norm singular values matrix. singular value thresholding encourages low-rank L matrix low-rank root_pcp(). proximal gradient method used solve non-differentiable convex optimization problems. internal function needed root_pcp(). expected users require access function.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_nuclear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proximal gradient method for the nuclear norm — prox_nuclear","text":"","code":"prox_nuclear(L, c)"},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_nuclear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proximal gradient method for the nuclear norm — prox_nuclear","text":"L input low-rank matrix. c amount prox nuclear method penalizes L.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/prox_nuclear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proximal gradient method for the nuclear norm — prox_nuclear","text":"list containing: X: thresholded low-rank matrix. X_nuclear_norm: sum absolute values thresholded singular values (used objective function).","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/queens.html","id":null,"dir":"Reference","previous_headings":"","what":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","title":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","text":"dataset containing chemical concentrations (µg/m^3) 26 PM2.5 species measured every three six days 04/04/2001 12/30/2021 Queens, New York City. Data obtained U.S. Environmental Protection Agency's Air Quality System data mart (site ID: 36-081-0124).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/queens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","text":"","code":"queens"},{"path":"https://columbia-prime.github.io/pcpr/reference/queens.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","text":"tibble 2443 rows 27 variables: Date: date PM2.5 measurements made ...: remaining 26 variables 26 PM2.5 species: Al, NH4, , Ba, Br, Cd, Ca, Cl, Cr, Cu, EC, Fe, Pb, Mg, Mn, Ni, OC, K, Se, Si, Na, S, Ti, NO3, V, Zn","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/queens.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","text":"https://epa.maps.arcgis.com/apps/webappviewer/index.html?id=5f239fd3e72f424f98ef3d5def547eb5","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/queens.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Daily chemical concentrations of 26 PM2.5 species from Queens, NY (2001-2021) — queens","text":"US Environmental Protection Agency. Air Quality System Data Mart internet database available via https://www.epa.gov/outdoor-air-quality-data. Accessed July 15, 2022.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":null,"dir":"Reference","previous_headings":"","what":"Square root principal component pursuit (convex PCP) — root_pcp","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"root_pcp() implements convex PCP algorithm \"Square root principal component pursuit\" described Zhang et al. (2021) , outfitted environmental health (EH)-specific extensions described Gibson et al. (2022). Given observed data matrix D, regularization parameters lambda mu, root_pcp() aims find best low-rank sparse estimates L S. L matrix encodes latent patterns govern observed data. S matrix captures extreme events data unexplained underlying patterns L. convex, root_pcp() determines rank r, number latent patterns data, autonomously optimization. , user need specify desired rank r output L matrix non-convex PCP model rrmc(). Experimentally, root_pcp() approach PCP modeling best able handle datasets governed well-defined underlying patterns, characterized quickly decaying singular values. typical imaging video data, uncommon EH data. observed data complex low rank structure (slowly decaying singular values), like EH data, rrmc() may offer better model estimate. Three EH-specific extensions currently supported root_pcp(): model can handle missing values input data matrix D; model can also handle measurements fall limit detection (LOD), provided LOD information user; model also equipped optional non-negativity constraint low-rank L matrix, ensuring output values L \\(> 0\\).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"","code":"root_pcp(   D,   lambda = NULL,   mu = NULL,   LOD = -Inf,   non_negative = TRUE,   max_iter = 10000,   verbose = FALSE )"},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"D input data matrix (can contain NA values). Note PCP converge much quickly D standardized way (e.g. scaling columns standard deviations, column-wise min-max normalization). lambda, mu (Optional) pair doubles regularizing recovery L S estimates. lambda controls sparsity output S matrix; larger values penalize non-zero entries S stringently, driving recovery sparser S matrices. mu adjusts model's sensitivity noise; larger values penalize errors predicted model observed data severely. highly recommended user tunes parameters using grid_search_cv() unique data matrix D. default, lambda mu NULL, case theoretically optimal values used, calculated according get_pcp_defaults(). LOD (Optional) limit detection (LOD) data. Entries D satisfy D >= LOD understood LOD, otherwise entries treated LOD. LOD can either: double, implying universal LOD common across measurements D; vector length ncol(D), signifying column-specific LOD, entry LOD vector corresponds LOD column D; matrix dimension dim(D), indicating observation-specific LOD, entry LOD matrix corresponds LOD entry D. default, LOD = -Inf, indicating known LODs PCP leverage. non_negative (Optional) logical indicating whether non-negativity constraint used constrain output L matrix entries \\(\\geq 0\\). default, non_negative = TRUE. max_iter (Optional) integer specifying maximum number iterations allow PCP giving meeting PCP's convergence criteria. default, max_iter = 10000, suitable problems. verbose (Optional) logical indicating whether print information real time course PCP's optimization. default, verbose = FALSE.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"list containing: L: rank-r low-rank matrix encoding r-many latent patterns governing observed input data matrix D. dim(L) dim(D). explicitly obtain underlying patterns, L can used input matrix factorization technique choice, e.g. PCA, factor analysis, non-negative matrix factorization. S: sparse matrix containing rare outlying extreme observations D explained underlying patterns corresponding L matrix. dim(S) dim(D). entries S 0, non-zero entries identify extreme outlying observations D. num_iter: number iterations taken reach convergence. num_iter == max_iter root_pcp() converge. objective: vector containing values root_pcp()'s objective function course optimization. converged: boolean indicating whether convergence criteria met max_iter reached.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"the-objective-function","dir":"Reference","previous_headings":"","what":"The objective function","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"root_pcp() optimizes following objective function: $$\\min_{L, S} ||L||_* + \\lambda ||S||_1 + \\mu ||L + S - D||_F$$ first term nuclear norm L matrix, incentivizing L low-rank. second term \\(\\ell_1\\) norm S matrix, encouraging S sparse. third term Frobenius norm applied model's noise, ensuring estimated low-rank sparse models L S together high fidelity observed data D. objective smooth differentiable, however convex separable. , optimized using Alternating Direction Method Multipliers (ADMM) algorithm Boyd et al. (2011), Gao et al. (2020).","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"the-lambda-and-mu-parameters","dir":"Reference","previous_headings":"","what":"The lambda and mu parameters","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"lambda controls sparsity root_pcp()'s output S matrix; larger values lambda penalize non-zero entries S stringently, driving recovery sparser S matrices. Therefore, priori expect outlying events model, might expect grid search recover relatively larger lambda values, vice-versa. mu adjusts root_pcp()'s sensitivity noise; larger values mu penalize errors predicted model observed data (.e. noise), severely. Environmental data subject higher noise levels therefore require root_pcp() model equipped smaller mu values (since higher noise means greater discrepancy observed mixture true underlying low-rank sparse model). virtually noise-free settings (e.g. simulations), larger values mu appropriate. default values lambda mu offer theoretical guarantees optimal estimation performance, stable recovery L S. \"stable\", mean root_pcp()'s reconstruction error , worst case, proportional magnitude noise corrupting observed data (\\(||Z||_F\\)), often outperforming upper bound. Candès et al. (2011) obtained guarantee lambda, Zhang et al. (2021) obtained result mu.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"environmental-health-specific-extensions","dir":"Reference","previous_headings":"","what":"Environmental health specific extensions","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"refer interested readers Gibson et al. (2022) complete details regarding EH-specific extensions. Missing value functionality: PCP assumes data generating mechanisms govern missing observed entries D. PCP primarily seeks accurate estimation patterns rather individual observations, assumption reasonable, edge cases may always justified. Missing values D therefore reconstructed recovered low-rank L matrix according underlying patterns L. three corollaries keep mind regarding quality recovered missing observations: Recovery missing entries D relies accurate estimation L; fewer observations D, harder accurately reconstruct L (therefore estimation unobserved observed measurements L degrades); Greater proportions missingness D artifically drive sparsity estimated S matrix. possible recover sparse event S corresponding entry D unobserved. definition, sparse events S explained consistent patterns L. Practically, 20% entries D missing, least 20% entries S 0. Handling measurements limit detection: equipped LOD information, PCP treats estimations values known LOD equally valid approximations fall 0 LOD. course optimization, observations LOD pushed known range \\([0, LOD]\\) using penalties : \\(< LOD\\) estimate \\(< 0\\), stringently penalized, since measured observations negative. hand, \\(< LOD\\) estimate \\(>\\) LOD, also heavily penalized: less \\(< 0\\), observations known LOD, prior information observations must LOD. Observations known LOD penalized usual, using Frobenius norm objective function. Gibson et al. (2022) demonstrates experimental settings 50% data corrupted LOD, PCP LOD extension boasts superior accuracy recovered L models compared PCA coupled \\(LOD / \\sqrt{2}\\) imputation. PCP even outperforms PCA low-noise scenarios much 75% data corrupted LOD. situations PCA bettered PCP pathological cases D characterized extreme noise huge proportions (.e., 75%) observations falling LOD. non-negativity constraint L: enhance interpretability PCP-rendered solutions, optional non-negativity constraint can imposed L matrix ensure estimated values within \\(\\geq 0\\). prevents researchers deal negative observation values questions surrounding meaning utility. Non-negative L models also allow seamless use methods non-negative matrix factorization extract non-negative patterns. non-negativity constraint incorporated ADMM splitting technique via introduction additional optimization variable corresponding constraint.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"Zhang, Junhui, Jingkai Yan, John Wright. \"Square root principal component pursuit: tuning-free noisy robust matrix recovery.\" Advances Neural Information Processing Systems 34 (2021): 29464-29475. [available ] Gibson, Elizabeth ., Junhui Zhang, Jingkai Yan, Lawrence Chillrud, Jaime Benavides, Yanelli Nunez, Julie B. Herbstman, Jeff Goldsmith, John Wright, Marianthi-Anna Kioumourtzoglou. \"Principal component pursuit pattern identification environmental mixtures.\" Environmental Health Perspectives 130, . 11 (2022): 117008. Boyd, Stephen, Neal Parikh, Eric Chu, Borja Peleato, Jonathan Eckstein. \"Distributed optimization statistical learning via alternating direction method multipliers.\" Foundations Trends Machine learning 3, . 1 (2011): 1-122. Gao, Wenbo, Donald Goldfarb, Frank E. Curtis. \"ADMM multiaffine constrained optimization.\" Optimization Methods Software 35, . 2 (2020): 257-303. Candès, Emmanuel J., Xiaodong Li, Yi Ma, John Wright. \"Robust principal component analysis?.\" Journal ACM (JACM) 58, . 3 (2011): 1-37.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/root_pcp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Square root principal component pursuit (convex PCP) — root_pcp","text":"","code":"####-------Simple simulated PCP problem-------#### # First we will simulate a simple dataset with the sim_data() function. # The dataset will be a 100x10 matrix comprised of: # 1. A rank-2 component as the ground truth L matrix; # 2. A ground truth sparse component S w/outliers along the diagonal; and # 3. A dense Gaussian noise component data <- sim_data(r = 2, sparse_nonzero_idxs = seq(1, 1000, 101), sigma = 0.1) # Normally we would conduct grid search to tune lambda and mu. But, to keep # the example short, we will just use best parameters found in the below grid # search example: if (FALSE) { # \\dontrun{ lambda_0 <- get_pcp_defaults(data$D)$lambda mu_0 <- get_pcp_defaults(data$D)$mu lambdas <- lambda_0 + seq(-0.05, 0.2, 0.025) mus <- mu_0 + seq(-1, 1, 0.3) params <- expand.grid(lambdas, mus) names(params) <- c(\"lambda\", \"mu\") gs <- grid_search_cv(data$D, root_pcp, params) dplyr::arrange(gs$summary_stats, rel_err) } # } # The gs found the best parameters to be lambda = 0.225 and mu = 3.04 pcp_model <- root_pcp(data$D, lambda = 0.225, mu = 3.04) data.frame(   \"Estimated_L_rank\" = matrix_rank(pcp_model$L, 5e-2),   \"Observed_relative_error\" = norm(data$L - data$D, \"F\") / norm(data$L, \"F\"),   \"PCA_error\" = norm(data$L - proj_rank_r(data$D, r = 2), \"F\") / norm(data$L, \"F\"),   \"PCP_L_error\" = norm(data$L - pcp_model$L, \"F\") / norm(data$L, \"F\"),   \"PCP_S_error\" = norm(data$S - pcp_model$S, \"F\") / norm(data$S, \"F\") ) #>   Estimated_L_rank Observed_relative_error PCA_error PCP_L_error PCP_S_error #> 1                2               0.2298567 0.1040869  0.09485763   0.2453499 # Results: # PCP found a rank 2 solution! # PCP outperformed PCA in it's recovery of the L matrix (even though we let # PCA \"cheat\" by telling PCA it was looking for a rank 2 solution)! # PCP successfully isolated the outlying events in S!"},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank-based robust matrix completion (non-convex PCP) — rrmc","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"rrmc() implements non-convex PCP algorithm \"Rank-based robust matrix completion\" described Cherapanamjeri et al. (2017) (see Algorithm 3), outfitted environmental health (EH)-specific extensions described Gibson et al. (2022). Given observed data matrix D, maximum rank search r, regularization parameter eta, rrmc() seeks find best low-rank sparse estimates L S using incremental rank-based strategy. L matrix encodes latent patterns govern observed data. S matrix captures extreme events data unexplained underlying patterns L. rrmc()'s incremental rank-based strategy first estimates rank-1 model \\((L^(1), S^(1))\\), using rank-1 model initialization point construct rank-2 model \\((L^(2), S^(2))\\), , desired rank-r model \\((L^(r), S^(r))\\) recovered. models ranks 1 r returned rrmc() way. Experimentally, rrmc() approach PCP best able handle datasets governed complex underlying patterns characterized slowly decaying singular values, EH data. observed data well-defined low rank structure (rapidly decaying singular values), root_pcp() may offer better model estimate. Two EH-specific extensions currently supported rrmc(): model can handle missing values input data matrix D; model can also handle measurements fall limit detection (LOD), provided LOD information user. Support non-negativity constraint rrmc()'s output added future release pcpr.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"","code":"rrmc(D, r, eta = NULL, LOD = -Inf)"},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"D input data matrix (can contain NA values). Note PCP converge much quickly D standardized way (e.g. scaling columns standard deviations, column-wise min-max normalization). r integer specifying maximum rank PCP model return. models rank 1 r returned. eta (Optional) double defining ratio model's sensitivity sparse dense noise. Larger values eta place greater emphasis penalizing non-zero entries S penalizing dense noise Z, .e. errors predicted observed data Z = L + S - D. recommended tune eta using grid_search_cv() unique data matrix D. default, eta = NULL, case eta retrieved using get_pcp_defaults(). LOD (Optional) limit detection (LOD) data. Entries D satisfy D >= LOD understood LOD, otherwise entries treated LOD. LOD can either: double, implying universal LOD common across measurements D; vector length ncol(D), signifying column-specific LOD, entry LOD vector corresponds LOD column D; matrix dimension dim(D), indicating observation-specific LOD, entry LOD matrix corresponds LOD entry D. default, LOD = -Inf, indicating known LODs PCP leverage.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"list containing: L: rank-r low-rank matrix encoding r-many latent patterns governing observed input data matrix D. dim(L) dim(D). explicitly obtain underlying patterns, L can used input matrix factorization technique choice, e.g. PCA, factor analysis, non-negative matrix factorization. S: sparse matrix containing rare outlying extreme observations D explained underlying patterns corresponding L matrix. dim(S) dim(D). entries S 0, non-zero entries identify extreme outlying observations D. L_list: list r-many L matrices recovered course rrmc()'s iterative optimization procedure. first element L_list corresponds rank-1 L matrix, second rank-2 L matrix, . S_list: list r-many corresponding S matrices recovered course rrmc()'s iterative optimization procedure. first element S_list corresponds rank-1 solution's S matrix, second rank-2 solution's S matrix, . objective: vector containing values rrmc()'s objective function course optimization.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"the-objective-function","dir":"Reference","previous_headings":"","what":"The objective function","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"rrmc() implicitly optimizes following objective function: $$\\min_{L, S} I_{rank(L) \\leq r} + \\eta ||S||_0 + ||L + S - D||_F^2$$ first term indicator function checking L matrix strictly rank r less, implemented using rank r projection operator proj_rank_r(). second term \\(\\ell_0\\) norm applied S matrix encourage sparsity, implemented help adaptive hard-thresholding operator hard_threshold(). third term squared Frobenius norm applied model's noise.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"the-eta-parameter","dir":"Reference","previous_headings":"","what":"The eta parameter","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"eta parameter scales sparse penalty applied rrmc()'s output sparse S matrix. Larger values eta penalize non-zero entries S stringently, driving recovery sparser S matrices. parameters scaling terms rrmc()'s objective function, eta can intuitively thought dial balances model's sensitivity extreme events (placed S) sensitivity noise Z (captured last term objective, measures discrepancy predicted model observed data). Larger values eta place greater emphasis penalizing non-zero entries S penalizing errors predicted observed data Z = L + S - D.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"environmental-health-specific-extensions","dir":"Reference","previous_headings":"","what":"Environmental health specific extensions","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"refer interested readers Gibson et al. (2022) complete details regarding EH-specific extensions. Missing value functionality: PCP assumes data generating mechanisms govern missing observed entries D. PCP primarily seeks accurate estimation patterns rather individual observations, assumption reasonable, edge cases may always justified. Missing values D therefore reconstructed recovered low-rank L matrix according underlying patterns L. three corollaries keep mind regarding quality recovered missing observations: Recovery missing entries D relies accurate estimation L; fewer observations D, harder accurately reconstruct L (therefore estimation unobserved observed measurements L degrades); Greater proportions missingness D artifically drive sparsity estimated S matrix. possible recover sparse event S corresponding entry D unobserved. definition, sparse events S explained consistent patterns L. Practically, 20% entries D missing, least 20% entries S 0. Handling measurements limit detection: equipped LOD information, PCP treats estimations values known LOD equally valid approximations fall 0 LOD. course optimization, observations LOD pushed known range \\([0, LOD]\\) using penalties : \\(< LOD\\) estimate \\(< 0\\), stringently penalized, since measured observations negative. hand, \\(< LOD\\) estimate \\(>\\) LOD, also heavily penalized: less \\(< 0\\), observations known LOD, prior information observations must LOD. Observations known LOD penalized usual, using Frobenius norm objective function. Gibson et al. (2022) demonstrates experimental settings 50% data corrupted LOD, PCP LOD extension boasts superior accuracy recovered L models compared PCA coupled \\(LOD / \\sqrt{2}\\) imputation. PCP even outperforms PCA low-noise scenarios much 75% data corrupted LOD. situations PCA bettered PCP pathological cases D characterized extreme noise huge proportions (.e., 75%) observations falling LOD.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"Cherapanamjeri, Yeshwanth, Kartik Gupta, Prateek Jain. \"Nearly optimal robust matrix completion.\" International Conference Machine Learning. PMLR, 2017. [available ] Gibson, Elizabeth ., Junhui Zhang, Jingkai Yan, Lawrence Chillrud, Jaime Benavides, Yanelli Nunez, Julie B. Herbstman, Jeff Goldsmith, John Wright, Marianthi-Anna Kioumourtzoglou. \"Principal component pursuit pattern identification environmental mixtures.\" Environmental Health Perspectives 130, . 11 (2022): 117008.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/rrmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank-based robust matrix completion (non-convex PCP) — rrmc","text":"","code":"####-------Simple simulated PCP problem-------#### # First we will simulate a simple dataset with the sim_data() function. # The dataset will be a 100x10 matrix comprised of: # 1. A rank-3 component as the ground truth L matrix; # 2. A ground truth sparse component S w/outliers in 1st & last entries; and # 3. A dense Gaussian noise component data <- sim_data() # Normally we would conduct grid search to tune eta. But, to keep the example # short, we will just use best parameters from the below grid search example: if (FALSE) { # \\dontrun{ eta_0 <- get_pcp_defaults(data$D)$eta eta_grid <- data.frame(\"eta\" = sort(c(0.1 * eta_0, eta_0 * seq(1, 10, 2))), \"r\" = 7) gs <- grid_search_cv(data$D, rrmc, eta_grid) dplyr::arrange(gs$summary_stats, rel_err) } # } # The gs found the best rank to be 3, and the best eta to be 0.3 or 0.4, so # we will split the difference and use an eta of 0.35 pcp_model <- rrmc(data$D, r = 3, eta = 0.35) data.frame(   \"Observed_relative_error\" = norm(data$L - data$D, \"F\") / norm(data$L, \"F\"),   \"PCA_error\" = norm(data$L - proj_rank_r(data$D, r = 3), \"F\") / norm(data$L, \"F\"),   \"PCP_L_error\" = norm(data$L - pcp_model$L, \"F\") / norm(data$L, \"F\"),   \"PCP_S_error\" = norm(data$S - pcp_model$S, \"F\") / norm(data$S, \"F\") ) #>   Observed_relative_error  PCA_error PCP_L_error PCP_S_error #> 1              0.07876326 0.04070336  0.03289421  0.05839639 # Results: # The grid search correctly found the rank (3) of the ground truth L matrix! # PCP outperformed PCA in it's recovery of the L matrix (even though we let # PCA \"cheat\" by telling PCA it was looking for a rank 3 solution)! # PCP successfully isolated the outlying event in S!"},{"path":"https://columbia-prime.github.io/pcpr/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate data — sim_data","title":"Simulate data — sim_data","text":"sim_data() generates simulated dataset D = L + S + Z experimentation Principal Component Pursuit (PCP) algorithms.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate data — sim_data","text":"","code":"sim_data(   n = 100,   p = 10,   r = 3,   sparse_nonzero_idxs = NULL,   sigma = 0.05,   seed = 42 )"},{"path":"https://columbia-prime.github.io/pcpr/reference/sim_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate data — sim_data","text":"n, p (Optional) pair integers specifying simulated dataset's number n observations (rows) p variables (columns). default, n = 100, p = 10. r (Optional) integer specifying rank simulated dataset's low-rank component. Intuitively, number latent patterns governing simulated dataset. default, r = 3. sparse_nonzero_idxs (Optional) integer vector specifying indices non-zero elements sparse component. default, sparse_nonzero_idxs = NULL, case defined vector c(1, n * p) (placing sparse noise first last entries simulated dataset). sigma (Optional) double specifying standard deviation dense (Gaussian) noise component Z. default, sigma = 0.05. seed (Optional) integer specifying seed random number generation. default, seed = 42.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sim_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate data — sim_data","text":"list containing: D: observed data matrix, D = L + S + Z. L: ground truth rank-r low-rank matrix. S: ground truth sparse matrix. S: ground truth dense (Gaussian) noise matrix.","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate data — sim_data","text":"","code":"# rank 3 example data <- sim_data() matrix_rank(data$D) #> [1] 10 matrix_rank(data$L) #> [1] 3 # rank 7 example data <- sim_data(n = 1000, p = 25, r = 7) matrix_rank(data$D) #> [1] 25 matrix_rank(data$L) #> [1] 7"},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute singular values of given matrix — sing","title":"Compute singular values of given matrix — sing","text":"sing() calculates singular values given data matrix D. done call svd(), included pcpr enable quick characterization data matrix's raw low-rank structure, help decide whether rrmc() root_pcp() appropriate PCP algorithm employ conjunction D. Experimentally, rrmc() approach PCP best able handle datasets governed complex underlying patterns characterized slowly decaying singular values, EH data. observed data well-defined low rank structure (rapidly decaying singular values), root_pcp() may offer better model estimate.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute singular values of given matrix — sing","text":"","code":"sing(D)"},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute singular values of given matrix — sing","text":"D input data matrix.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute singular values of given matrix — sing","text":"numeric vector containing singular values D.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute singular values of given matrix — sing","text":"\"Singular value decomposition\" Wikipedia article.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute singular values of given matrix — sing","text":"","code":"data <- sim_data() sing(data$D) #>  [1] 27.3359578  2.8782309  2.2675947  1.1444730  0.9990220  0.5674336 #>  [7]  0.5121203  0.4584272  0.4516461  0.4085756 # could plot the singular values for visual inspection with e.g. # plot(sing(data$D), type = 'b')"},{"path":"https://columbia-prime.github.io/pcpr/reference/sparsity.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate sparsity of given matrix — sparsity","title":"Estimate sparsity of given matrix — sparsity","text":"sparsity() estimates percentage entries given data matrix D whose values \"practically zero\". absolute value entry given threshold parameter thresh, value determined \"practically zero\", increasing estimated sparsity D.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sparsity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate sparsity of given matrix — sparsity","text":"","code":"sparsity(D, thresh = 1e-04)"},{"path":"https://columbia-prime.github.io/pcpr/reference/sparsity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate sparsity of given matrix — sparsity","text":"D input data matrix. thresh (Optional) numeric threshold >= 0 used determine entry D \"practically zero\". absolute value entry thresh, judged \"practically zero\". default, thresh = 1e-04.","code":""},{"path":"https://columbia-prime.github.io/pcpr/reference/sparsity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate sparsity of given matrix — sparsity","text":"sparsity D, measured percentage entries D \"practically zero\".","code":""},{"path":[]},{"path":"https://columbia-prime.github.io/pcpr/reference/sparsity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate sparsity of given matrix — sparsity","text":"","code":"sparsity(matrix(rep(c(1, 0), 8), 4, 4)) #> [1] 50 sparsity(matrix(0:8, 3, 3)) #> [1] 11.11111 sparsity(matrix(0, 3, 3)) #> [1] 100"},{"path":"https://columbia-prime.github.io/pcpr/news/index.html","id":"pcpr-100","dir":"Changelog","previous_headings":"","what":"pcpr 1.0.0","title":"pcpr 1.0.0","text":"Initial CRAN submission.","code":""}]
