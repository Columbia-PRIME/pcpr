<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rank-based robust matrix completion (non-convex PCP) — rrmc • pcpr</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><script src="../deps/MathJax-3.2.2/tex-chtml.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Rank-based robust matrix completion (non-convex PCP) — rrmc"><meta name="description" content="rrmc() implements the non-convex PCP algorithm &quot;Rank-based robust matrix
completion&quot; as described in
Cherapanamjeri et al. (2017)
(see Algorithm 3), outfitted with environmental health (EH)-specific
extensions as described in Gibson et al. (2022).
Given an observed data matrix D, maximum rank to search up to r, and
regularization parameter eta, rrmc() seeks to find the best low-rank
and sparse estimates L and S using an incremental rank-based strategy.
The L matrix encodes latent patterns that govern the observed data.
The S matrix captures any extreme events in the data unexplained by the
underlying patterns in L.
rrmc()'s incremental rank-based strategy first estimates a rank-1 model
\((L^{(1)}, S^{(1)})\), before using the rank-1 model as the initialization
point to then construct a rank-2 model \((L^{(2)}, S^{(2)})\), and so on,
until the desired rank-r model \((L^{(r)}, S^{(r)})\) is recovered. All
models from ranks 1 through r are returned by rrmc() in this way.
Experimentally, the rrmc() approach to PCP has best been able to handle
those datasets that are governed by complex underlying patterns characterized
by slowly decaying singular values, such as EH data. For observed data with a
well-defined low rank structure (rapidly decaying singular values),
root_pcp() may offer a better model estimate.
Two EH-specific extensions are currently supported by rrmc():
The model can handle missing values in the input data matrix D; and
The model can also handle measurements that fall below the limit of
detection (LOD), if provided LOD information by the user.


Support for a non-negativity constraint on rrmc()'s output will be added in
a future release of pcpr."><meta property="og:description" content="rrmc() implements the non-convex PCP algorithm &quot;Rank-based robust matrix
completion&quot; as described in
Cherapanamjeri et al. (2017)
(see Algorithm 3), outfitted with environmental health (EH)-specific
extensions as described in Gibson et al. (2022).
Given an observed data matrix D, maximum rank to search up to r, and
regularization parameter eta, rrmc() seeks to find the best low-rank
and sparse estimates L and S using an incremental rank-based strategy.
The L matrix encodes latent patterns that govern the observed data.
The S matrix captures any extreme events in the data unexplained by the
underlying patterns in L.
rrmc()'s incremental rank-based strategy first estimates a rank-1 model
\((L^{(1)}, S^{(1)})\), before using the rank-1 model as the initialization
point to then construct a rank-2 model \((L^{(2)}, S^{(2)})\), and so on,
until the desired rank-r model \((L^{(r)}, S^{(r)})\) is recovered. All
models from ranks 1 through r are returned by rrmc() in this way.
Experimentally, the rrmc() approach to PCP has best been able to handle
those datasets that are governed by complex underlying patterns characterized
by slowly decaying singular values, such as EH data. For observed data with a
well-defined low rank structure (rapidly decaying singular values),
root_pcp() may offer a better model estimate.
Two EH-specific extensions are currently supported by rrmc():
The model can handle missing values in the input data matrix D; and
The model can also handle measurements that fall below the limit of
detection (LOD), if provided LOD information by the user.


Support for a non-negativity constraint on rrmc()'s output will be added in
a future release of pcpr."><meta property="og:image" content="https://columbia-prime.github.io/pcpr/logo.png"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">pcpr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/pcp-applied.html">Air pollution source apportionment with PCP</a></li>
    <li><a class="dropdown-item" href="../articles/pcp-quickstart.html">Quickstart: applying PCP to a simulated environmental mixture</a></li>
    <li><a class="dropdown-item" href="../articles/theory-crash-course.html">Theory crash course</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/Columbia-PRIME/pcpr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch"><li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Rank-based robust matrix completion (non-convex PCP)</h1>
      <small class="dont-index">Source: <a href="https://github.com/Columbia-PRIME/pcpr/blob/main/R/rrmc.R" class="external-link"><code>R/rrmc.R</code></a></small>
      <div class="d-none name"><code>rrmc.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>rrmc()</code> implements the non-convex PCP algorithm "Rank-based robust matrix
completion" as described in
<a href="https://proceedings.mlr.press/v70/cherapanamjeri17a.html" class="external-link">Cherapanamjeri et al. (2017)</a>
(see Algorithm 3), outfitted with environmental health (EH)-specific
extensions as described in Gibson et al. (2022).</p>
<p>Given an observed data matrix <code>D</code>, maximum rank to search up to <code>r</code>, and
regularization parameter <code>eta</code>, <code>rrmc()</code> seeks to find the best low-rank
and sparse estimates <code>L</code> and <code>S</code> using an incremental rank-based strategy.
The <code>L</code> matrix encodes latent patterns that govern the observed data.
The <code>S</code> matrix captures any extreme events in the data unexplained by the
underlying patterns in <code>L</code>.</p>
<p><code>rrmc()</code>'s incremental rank-based strategy first estimates a rank-<code>1</code> model
\((L^{(1)}, S^{(1)})\), before using the rank-<code>1</code> model as the initialization
point to then construct a rank-<code>2</code> model \((L^{(2)}, S^{(2)})\), and so on,
until the desired rank-<code>r</code> model \((L^{(r)}, S^{(r)})\) is recovered. All
models from ranks <code>1</code> through <code>r</code> are returned by <code>rrmc()</code> in this way.</p>
<p>Experimentally, the <code>rrmc()</code> approach to PCP has best been able to handle
those datasets that are governed by complex underlying patterns characterized
by slowly decaying singular values, such as EH data. For observed data with a
well-defined low rank structure (rapidly decaying singular values),
<code><a href="root_pcp.html">root_pcp()</a></code> may offer a better model estimate.</p>
<p>Two EH-specific extensions are currently supported by <code>rrmc()</code>:</p><ol><li><p>The model can handle missing values in the input data matrix <code>D</code>; and</p></li>
<li><p>The model can also handle measurements that fall below the limit of
detection (LOD), if provided <code>LOD</code> information by the user.</p></li>
</ol><p>Support for a non-negativity constraint on <code>rrmc()</code>'s output will be added in
a future release of <code>pcpr</code>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">rrmc</span><span class="op">(</span><span class="va">D</span>, <span class="va">r</span>, eta <span class="op">=</span> <span class="cn">NULL</span>, LOD <span class="op">=</span> <span class="op">-</span><span class="cn">Inf</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-d">D<a class="anchor" aria-label="anchor" href="#arg-d"></a></dt>
<dd><p>The input data matrix (can contain <code>NA</code> values). Note that PCP will
converge much more quickly when <code>D</code> has been standardized in some way (e.g.
scaling columns by their standard deviations, or column-wise min-max
normalization).</p></dd>


<dt id="arg-r">r<a class="anchor" aria-label="anchor" href="#arg-r"></a></dt>
<dd><p>An integer <code>&gt;= 1</code> specifying the maximum rank PCP model to return.
All models from rank <code>1</code> through <code>r</code> will be returned.</p></dd>


<dt id="arg-eta">eta<a class="anchor" aria-label="anchor" href="#arg-eta"></a></dt>
<dd><p>(Optional) A double in the range <code>[0, Inf)</code> defining the ratio
between the model's sensitivity to sparse and dense noise.
Larger values of <code>eta</code> will place a greater emphasis on penalizing the
non-zero entries in <code>S</code> over penalizing dense noise <code>Z</code>, i.e. errors
between the predicted and observed data <code>Z = L + S - D</code>. It is recommended
to tune <code>eta</code> using <code><a href="grid_search_cv.html">grid_search_cv()</a></code> for each unique data matrix <code>D</code>. By
default, <code>eta = NULL</code>, in which case <code>eta</code> is retrieved using
<code><a href="get_pcp_defaults.html">get_pcp_defaults()</a></code>.</p></dd>


<dt id="arg-lod">LOD<a class="anchor" aria-label="anchor" href="#arg-lod"></a></dt>
<dd><p>(Optional) The limit of detection (LOD) data. Entries in <code>D</code> that
satisfy <code>D &gt;= LOD</code> are understood to be above the LOD, otherwise those
entries are treated as below the LOD. <code>LOD</code> can be either:</p><ul><li><p>A double, implying a universal LOD common across all measurements in <code>D</code>;</p></li>
<li><p>A vector of length <code>ncol(D)</code>, signifying a column-specific LOD, where
each entry in the <code>LOD</code> vector corresponds to the LOD for each column in
<code>D</code>; or</p></li>
<li><p>A matrix of dimension <code>dim(D)</code>, indicating an observation-specific LOD,
where each entry in the <code>LOD</code> matrix corresponds to the LOD for each
entry in <code>D</code>.</p></li>
</ul><p>By default, <code>LOD = -Inf</code>, indicating there are no known LODs for PCP to
leverage.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A list containing:</p><ul><li><p><code>L</code>: The rank-<code>r</code> low-rank matrix encoding the <code>r</code>-many latent patterns
governing the observed input data matrix <code>D</code>. <code>dim(L)</code> will be the same
as <code>dim(D)</code>. To explicitly obtain the underlying patterns, <code>L</code> can be
used as the input to any matrix factorization technique of choice, e.g.
PCA, factor analysis, or non-negative matrix factorization.</p></li>
<li><p><code>S</code>: The sparse matrix containing the rare outlying or extreme
observations in <code>D</code> that are not explained by the underlying patterns in
the corresponding <code>L</code> matrix. <code>dim(S)</code> will be the same as <code>dim(D)</code>.
Most entries in <code>S</code> are <code>0</code>, while non-zero entries identify the extreme
outlying observations in <code>D</code>.</p></li>
<li><p><code>L_list</code>: A list of the <code>r</code>-many <code>L</code> matrices recovered over the course
of <code>rrmc()</code>'s iterative optimization procedure. The first element in
<code>L_list</code> corresponds to the rank-<code>1</code> <code>L</code> matrix, the second to the
rank-<code>2</code> <code>L</code> matrix, and so on.</p></li>
<li><p><code>S_list</code>: A list of the <code>r</code>-many corresponding <code>S</code> matrices recovered
over the course of <code>rrmc()</code>'s iterative optimization procedure. The first
element in <code>S_list</code> corresponds to the rank-<code>1</code> solution's <code>S</code> matrix,
the second to the rank-<code>2</code> solution's <code>S</code> matrix, and so on.</p></li>
<li><p><code>objective</code>: A vector containing the values of <code>rrmc()</code>'s objective
function over the course of optimization.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="the-objective-function">The objective function<a class="anchor" aria-label="anchor" href="#the-objective-function"></a></h2>


<p><code>rrmc()</code> implicitly optimizes the following objective function:
$$\min_{L, S} I_{rank(L) \leq r} + \eta ||S||_0 + ||L + S - D||_F^2$$
The first term is the indicator function checking that the <code>L</code> matrix is
strictly rank <code>r</code> or less, implemented using a rank <code>r</code> projection operator
<code><a href="proj_rank_r.html">proj_rank_r()</a></code>. The second term is the \(\ell_0\) norm applied to the <code>S</code>
matrix to encourage sparsity, and is implemented with the help of an adaptive
hard-thresholding operator <code><a href="hard_threshold.html">hard_threshold()</a></code>. The third term is the squared
Frobenius norm applied to the model's noise.</p>
    </div>
    <div class="section level2">
    <h2 id="the-eta-parameter">The <code>eta</code> parameter<a class="anchor" aria-label="anchor" href="#the-eta-parameter"></a></h2>


<p>The <code>eta</code> parameter scales the sparse penalty applied to <code>rrmc()</code>'s output
sparse <code>S</code> matrix. Larger values of <code>eta</code> penalize non-zero entries in <code>S</code>
more stringently, driving the recovery of sparser <code>S</code> matrices.</p>
<p>Because there are no other parameters scaling the other terms in <code>rrmc()</code>'s
objective function, <code>eta</code> can intuitively be thought of as the dial that
balances the model's sensitivity to extreme events (placed in <code>S</code>) and
its sensitivity to noise <code>Z</code> (captured by the last term in the objective,
which measures the discrepancy between the between the predicted model
and the observed data). Larger values of <code>eta</code> will place a
greater emphasis on penalizing the non-zero entries in <code>S</code> over penalizing
the errors between the predicted and observed data <code>Z = L + S - D</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="environmental-health-specific-extensions">Environmental health specific extensions<a class="anchor" aria-label="anchor" href="#environmental-health-specific-extensions"></a></h2>


<p>We refer interested readers to
Gibson et al. (2022) for the complete details regarding the EH-specific
extensions.</p>
<p><strong>Missing value functionality:</strong> PCP assumes that the same data generating
mechanisms govern both the missing and the observed entries in <code>D</code>. Because
PCP primarily seeks accurate estimation of <em>patterns</em> rather than
individual <em>observations</em>, this assumption is reasonable, but in some edge
cases may not always be justified. Missing values in <code>D</code> are therefore
reconstructed in the recovered low-rank <code>L</code> matrix according to the
underlying patterns in <code>L</code>. There are three corollaries to keep in mind
regarding the quality of recovered missing observations:</p><ol><li><p>Recovery of missing entries in <code>D</code> relies on accurate estimation of
<code>L</code>;</p></li>
<li><p>The fewer observations there are in <code>D</code>, the harder it is to accurately
reconstruct <code>L</code> (therefore estimation of <em>both</em> unobserved <em>and</em> observed
measurements in <code>L</code> degrades); and</p></li>
<li><p>Greater proportions of missingness in <code>D</code> artifically drive up the
sparsity of the estimated <code>S</code> matrix. This is because it is not possible
to recover a sparse event in <code>S</code> when the corresponding entry in <code>D</code> is
unobserved. By definition, sparse events in <code>S</code> cannot be explained by
the consistent patterns in <code>L</code>. Practically, if 20% of the entries in <code>D</code>
are missing, then at least 20% of the entries in <code>S</code> will be 0.</p></li>
</ol><p><strong>Handling measurements below the limit of detection:</strong> When equipped with
LOD information, PCP treats any estimations of values known to be below the
LOD as equally valid if their approximations fall between 0 and the LOD. Over
the course of optimization, observations below the LOD are pushed into this
known range \([0, LOD]\) using penalties from above and below: should a
\(&lt; LOD\) estimate be \(&lt; 0\), it is stringently penalized, since
measured observations cannot be negative. On the other hand, if a \(&lt; LOD\)
estimate is \(&gt;\) the LOD, it is also heavily penalized: less so than when
\(&lt; 0\), but more so than observations known to be above the LOD, because
we have prior information that these observations must be below LOD.
Observations known to be above the LOD are penalized as usual, using the
Frobenius norm in the above objective function.</p>
<p>Gibson et al. (2022) demonstrates that
in experimental settings with up to 50% of the data corrupted below the LOD,
PCP with the LOD extension boasts superior accuracy of recovered <code>L</code> models
compared to PCA coupled with \(LOD / \sqrt{2}\) imputation. PCP even
outperforms PCA in low-noise scenarios with as much as 75% of the data
corrupted below the LOD. The few situations in which PCA bettered PCP were
those pathological cases in which <code>D</code> was characterized by extreme noise and
huge proportions (i.e., 75%) of observations falling below the LOD.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Cherapanamjeri, Yeshwanth, Kartik Gupta, and Prateek Jain.
"Nearly optimal robust matrix completion."
International Conference on Machine Learning. PMLR, 2017. [available
<a href="https://proceedings.mlr.press/v70/cherapanamjeri17a.html" class="external-link">here</a>]</p>
<p>Gibson, Elizabeth A., Junhui Zhang, Jingkai Yan, Lawrence
Chillrud, Jaime Benavides, Yanelli Nunez, Julie B. Herbstman, Jeff
Goldsmith, John Wright, and Marianthi-Anna Kioumourtzoglou.
"Principal component pursuit for pattern identification in
environmental mixtures." Environmental Health Perspectives 130, no.
11 (2022): 117008.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="root_pcp.html">root_pcp()</a></code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co">#### -------Simple simulated PCP problem-------####</span></span></span>
<span class="r-in"><span><span class="co"># First we will simulate a simple dataset with the sim_data() function.</span></span></span>
<span class="r-in"><span><span class="co"># The dataset will be a 100x10 matrix comprised of:</span></span></span>
<span class="r-in"><span><span class="co"># 1. A rank-3 component as the ground truth L matrix;</span></span></span>
<span class="r-in"><span><span class="co"># 2. A ground truth sparse component S w/outliers along the diagonal; and</span></span></span>
<span class="r-in"><span><span class="co"># 3. A dense Gaussian noise component</span></span></span>
<span class="r-in"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_data.html">sim_data</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Normally we would conduct grid search to tune eta. But, to keep the example</span></span></span>
<span class="r-in"><span><span class="co"># short, we will just use best parameters from the below grid search example:</span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="va">eta_0</span> <span class="op">&lt;-</span> <span class="fu"><a href="get_pcp_defaults.html">get_pcp_defaults</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">D</span><span class="op">)</span><span class="op">$</span><span class="va">eta</span></span></span>
<span class="r-in"><span><span class="va">eta_grid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="st">"eta"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span> <span class="op">*</span> <span class="va">eta_0</span>, <span class="va">eta_0</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">10</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, <span class="st">"r"</span> <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">gs</span> <span class="op">&lt;-</span> <span class="fu"><a href="grid_search_cv.html">grid_search_cv</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">D</span>, <span class="va">rrmc</span>, <span class="va">eta_grid</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/arrange.html" class="external-link">arrange</a></span><span class="op">(</span><span class="va">gs</span><span class="op">$</span><span class="va">summary_stats</span>, <span class="va">rel_err</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
<span class="r-in"><span><span class="co"># The gs found the best rank to be 3, and the best eta to be 0.3 or 0.4, so</span></span></span>
<span class="r-in"><span><span class="co"># we will split the difference and use an eta of 0.35</span></span></span>
<span class="r-in"><span><span class="va">pcp_model</span> <span class="op">&lt;-</span> <span class="fu">rrmc</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">D</span>, r <span class="op">=</span> <span class="fl">3</span>, eta <span class="op">=</span> <span class="fl">0.35</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="st">"Observed_relative_error"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span> <span class="op">-</span> <span class="va">data</span><span class="op">$</span><span class="va">D</span>, <span class="st">"F"</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span>, <span class="st">"F"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="st">"PCA_error"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span> <span class="op">-</span> <span class="fu"><a href="proj_rank_r.html">proj_rank_r</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">D</span>, r <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="st">"F"</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span>, <span class="st">"F"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="st">"PCP_L_error"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span> <span class="op">-</span> <span class="va">pcp_model</span><span class="op">$</span><span class="va">L</span>, <span class="st">"F"</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">L</span>, <span class="st">"F"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="st">"PCP_S_error"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">S</span> <span class="op">-</span> <span class="va">pcp_model</span><span class="op">$</span><span class="va">S</span>, <span class="st">"F"</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">S</span>, <span class="st">"F"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   Observed_relative_error PCA_error PCP_L_error PCP_S_error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1               0.1286753 0.0738434  0.03283472  0.04249677</span>
<span class="r-in"><span><span class="co"># Results:</span></span></span>
<span class="r-in"><span><span class="co"># The grid search correctly found the rank (3) of the ground truth L matrix!</span></span></span>
<span class="r-in"><span><span class="co"># PCP outperformed PCA in it's recovery of the L matrix (even though we let</span></span></span>
<span class="r-in"><span><span class="co"># PCA "cheat" by telling PCA it was looking for a rank 3 solution)!</span></span></span>
<span class="r-in"><span><span class="co"># PCP successfully isolated the outlying event in S!</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://lawrence-chillrud.github.io/" class="external-link">Lawrence G. Chillrud</a>, <a href="https://www.linkedin.com/in/jaime-benavides-72959356/" class="external-link">Jaime Benavides</a>, <a href="https://lizzy.codes/index.html" class="external-link">Elizabeth A. Gibson</a>, <a href="https://scholar.google.com/citations?user=LyLU8koAAAAJ&amp;hl=en" class="external-link">Junhui Zhang</a>, <a href="https://www.linkedin.com/in/jingkai-yan-a49a9516a/" class="external-link">Jingkai Yan</a>, <a href="https://www.columbia.edu/~jw2966/" class="external-link">John N. Wright</a>, <a href="https://jeffgoldsmith.com/" class="external-link">Jeff Goldsmith</a>, <a href="https://marianthi.github.io/makLAB.github.io/" class="external-link">Marianthi-Anna Kioumourtzoglou</a>, <a href="https://www.publichealth.columbia.edu/" class="external-link"><img src="https://www.publichealth.columbia.edu/sites/default/files/logo-mailman-blue-horizontal.svg?stefxf" width="240" alt=""></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

