<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cross-validated grid search for PCP models — grid_search_cv • pcpr</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><script src="../deps/MathJax-3.2.2/tex-chtml.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Cross-validated grid search for PCP models — grid_search_cv"><meta name="description" content="grid_search_cv() conducts a Monte Carlo style cross-validated grid search
of PCP parameters for a given data matrix D, PCP function pcp_fn, and
grid of parameter settings to search through grid. The run time of the grid
search can be sped up using bespoke parallelization settings. The call to
grid_search_cv() can be wrapped in a call to progressr::with_progress()
for progress bar updates. See the below sections for details."><meta property="og:description" content="grid_search_cv() conducts a Monte Carlo style cross-validated grid search
of PCP parameters for a given data matrix D, PCP function pcp_fn, and
grid of parameter settings to search through grid. The run time of the grid
search can be sped up using bespoke parallelization settings. The call to
grid_search_cv() can be wrapped in a call to progressr::with_progress()
for progress bar updates. See the below sections for details."><meta property="og:image" content="https://columbia-prime.github.io/pcpr/logo.png"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">pcpr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/pcp-applied.html">Air pollution source apportionment with PCP</a></li>
    <li><a class="dropdown-item" href="../articles/pcp-quickstart.html">Quickstart: applying PCP to a simulated environmental mixture</a></li>
    <li><a class="dropdown-item" href="../articles/theory-crash-course.html">Theory crash course</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/Columbia-PRIME/pcpr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch"><li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Cross-validated grid search for PCP models</h1>
      <small class="dont-index">Source: <a href="https://github.com/Columbia-PRIME/pcpr/blob/v1.0.0/R/grid_search_cv.R" class="external-link"><code>R/grid_search_cv.R</code></a></small>
      <div class="d-none name"><code>grid_search_cv.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>grid_search_cv()</code> conducts a Monte Carlo style cross-validated grid search
of PCP parameters for a given data matrix <code>D</code>, PCP function <code>pcp_fn</code>, and
grid of parameter settings to search through <code>grid</code>. The run time of the grid
search can be sped up using bespoke parallelization settings. The call to
<code>grid_search_cv()</code> can be wrapped in a call to <code><a href="https://progressr.futureverse.org/reference/with_progress.html" class="external-link">progressr::with_progress()</a></code>
for progress bar updates. See the below sections for details.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">grid_search_cv</span><span class="op">(</span></span>
<span>  <span class="va">D</span>,</span>
<span>  <span class="va">pcp_fn</span>,</span>
<span>  <span class="va">grid</span>,</span>
<span>  <span class="va">...</span>,</span>
<span>  parallel_strategy <span class="op">=</span> <span class="st">"sequential"</span>,</span>
<span>  num_workers <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  perc_test <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>  num_runs <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  return_all_tests <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-d">D<a class="anchor" aria-label="anchor" href="#arg-d"></a></dt>
<dd><p>The input data matrix (can contain <code>NA</code> values). Note that PCP will
converge much more quickly when <code>D</code> has been standardized in some way (e.g.
scaling columns by their standard deviations, or column-wise min-max
normalization).</p></dd>


<dt id="arg-pcp-fn">pcp_fn<a class="anchor" aria-label="anchor" href="#arg-pcp-fn"></a></dt>
<dd><p>The PCP function to use when grid searching. Must be either
<code>rrmc</code> or <code>root_pcp</code> (passed without the soft brackets).</p></dd>


<dt id="arg-grid">grid<a class="anchor" aria-label="anchor" href="#arg-grid"></a></dt>
<dd><p>A <code>data.frame</code> of dimension <code>j</code> by <code>k</code> containing the <code>j</code>-many
unique settings of <code>k</code>-many parameters to try.
<strong>NOTE: The columns of <code>grid</code> should be
named after the required parameters in the function header of <code>pcp_fn</code>.</strong>
For example, if <code>pcp_fn = root_pcp</code> and you want to search through <code>lambda</code>
and <code>mu</code>, then <code>names(grid)</code> must be set to <code>c("lambda", "mu")</code>. If instead
you want to keep e.g. <code>lambda</code> fixed and search through only <code>mu</code>, you can
either have a <code>grid</code> with only one column, <code>mu</code>, and pass <code>lambda</code> as a
constant via <code>...</code>, or you can have <code>names(grid)</code> set to
<code>c("lambda", "mu")</code> where <code>lambda</code> is constant. The same logic applies for
<code>pcp_fn = rrmc</code> and <code>eta</code> and <code>r</code>.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Any parameters required by <code>pcp_fn</code> that should be kept constant
throughout the grid search, or those parameters that cannot be stored in
<code>grid</code> (e.g. the <code>LOD</code> parameter). A parameter should not be passed with
<code>...</code> if it is already a column in <code>grid</code>, as that behavior is ambiguous.</p></dd>


<dt id="arg-parallel-strategy">parallel_strategy<a class="anchor" aria-label="anchor" href="#arg-parallel-strategy"></a></dt>
<dd><p>(Optional) The parallelization strategy used when
conducting the grid search (to be passed on to the <code><a href="https://future.futureverse.org/reference/plan.html" class="external-link">future::plan()</a></code>
function). Must be one of: <code>"sequential"</code>, <code>"multisession"</code>, <code>"multicore"</code>
or <code>"cluster"</code>. By default, <code>parallel_strategy = "sequential"</code>, which
runs the grid search in serial and the <code>num_workers</code> argument is ignored.
The option <code>parallel_strategy = "multisession"</code> parallelizes the search
via sockets in separate R <em>sessions</em>. The option
<code>parallel_strategy = "multicore"</code> is not supported on Windows
machines, nor in .Rmd files (must be run in a .R script) but parallelizes
the search much faster than <code>"multisession"</code> since it runs separate
<em>forked</em> R processes. The option <code>parallel_strategy = "cluster"</code>
parallelizes using separate R sessions running typically on one or more
machines. Support for other parallel strategies will be added in a future
release of <code>pcpr</code>. <strong>It is recommended to use
<code>parallel_strategy = "multicore"</code> or <code>"multisession"</code> when possible.</strong></p></dd>


<dt id="arg-num-workers">num_workers<a class="anchor" aria-label="anchor" href="#arg-num-workers"></a></dt>
<dd><p>(Optional) An integer specifying the number of workers to
use when parallelizing the grid search, to be passed on to
<code><a href="https://future.futureverse.org/reference/plan.html" class="external-link">future::plan()</a></code>. By default, <code>num_workers = 1</code>. When possible, it is
recommended to use <code>num_workers = parallel::detectCores(logical = F)</code>,
which computes the number of physical CPUs available on the machine
(see <code><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">parallel::detectCores()</a></code>). <code>num_workers</code> is ignored
when <code>parallel_strategy = "sequential"</code>, and must be <code>&gt; 1</code> otherwise.</p></dd>


<dt id="arg-perc-test">perc_test<a class="anchor" aria-label="anchor" href="#arg-perc-test"></a></dt>
<dd><p>(Optional) The fraction of entries of <code>D</code> that will be
randomly corrupted as <code>NA</code> missing values (the test set). Can be anthing in
the range <code>[0, 1)</code>. By default, <code>perc_test = 0.05</code>. See <strong>Best practices</strong>
section for more details.</p></dd>


<dt id="arg-num-runs">num_runs<a class="anchor" aria-label="anchor" href="#arg-num-runs"></a></dt>
<dd><p>(Optional) The number of times to test a given parameter
setting. By default, <code>num_runs = 100</code>. See <strong>Best practices</strong> section for
more details.</p></dd>


<dt id="arg-return-all-tests">return_all_tests<a class="anchor" aria-label="anchor" href="#arg-return-all-tests"></a></dt>
<dd><p>(Optional) A logical indicating if you would like the
output from all the calls made to <code>pcp_fn</code> over the course of the grid
search to be returned to you in list format. If set to <code>FALSE</code>, then only
statistics on the parameters tested will be returned. If set to <code>TRUE</code> then
every <code>L</code>, and <code>S</code> matrix recovered during the grid search will be returned
in the lists <code>L_mats</code> and <code>S_mats</code>, every test set matrix will be returned
in the list <code>test_mats</code>, the original input matrix will be returned as
<code>original_mat</code>, and the parameters passed in to <code>...</code> will be returned in
the <code>constant_params</code> list. <strong>By default, <code>return_all_tests = FALSE</code>,
which is highly recommended. Setting <code>return_all_tests = TRUE</code> can consume
a massive amount of memory depending on the size of <code>grid</code>, the input
matrix <code>D</code>, and the value for <code>num_runs</code>.</strong></p></dd>


<dt id="arg-verbose">verbose<a class="anchor" aria-label="anchor" href="#arg-verbose"></a></dt>
<dd><p>(Optional) A logical indicating if you would like verbose
output displayed or not. By default, <code>verbose = TRUE</code>. To obtain
progress bar updates, the user must wrap the <code>grid_search_cv()</code> call
with a call to <code><a href="https://progressr.futureverse.org/reference/with_progress.html" class="external-link">progressr::with_progress()</a></code>. The progress bar does <em>not</em>
depend on the value passed for <code>verbose</code>.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A list containing:</p><ul><li><p><code>all_stats</code>: A <code>data.frame</code> containing the statistics of every run
comprising the grid search. These statistics include the parameter
settings for the run, along with the <code>run_num</code> (used as the seed
for the corruption step, step 1 in the grid search procedure),
the relative error for the run <code>rel_err</code>, the rank of the recovered L
matrix <code>L_rank</code>, the sparsity of the recovered S matrix <code>S_sparsity</code>,
the number of <code>iterations</code> PCP took to reach convergence (for <code><a href="root_pcp.html">root_pcp()</a></code>
only), and the error status <code>run_error</code> of the PCP run (<code>NA</code> if no error,
otherwise a character string).</p></li>
<li><p><code>summary_stats</code>: A <code>data.frame</code> containing a summary of the information in
<code>all_stats</code>. Summary made by column-wise averaging the results in
<code>all_stats</code>.</p></li>
<li><p><code>metadata</code>: A character string containing the metadata associated with the
grid search instance.</p></li>
</ul><p>If <code>return_all_tests = TRUE</code> then the following are also returned as part
of the list:</p><ul><li><p><code>L_mats</code>: A list containing all the <code>L</code> matrices returned from PCP
throughout the grid search. Therefore, <code>length(L_mats) == nrow(all_stats)</code>.
Row <code>i</code> in <code>all_stats</code> corresponds to <code>L_mats[[i]]</code>.</p></li>
<li><p><code>S_mats</code>: A list containing all the S matrices returned from PCP throughout
the grid search. Therefore, <code>length(S_mats) == nrow(all_stats)</code>. Row <code>i</code> in
<code>all_stats</code> corresponds to <code>S_mats[[i]]</code>.</p></li>
<li><p><code>test_mats</code>: A list of <code>length(num_runs)</code> containing all the corrupted test
mats (and their masks) used throughout the grid search. Note:
<code>all_stats$run[i]</code> corresponds to <code>test_mats[[i]]</code>.</p></li>
<li><p><code>original_mat</code>: The original data matrix <code>D</code>.</p></li>
<li><p><code>constant_params</code>: A copy of the constant parameters that were originally
passed to the grid search (for record keeping).</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="the-monte-carlo-style-cross-validation-procedure">The Monte Carlo style cross-validation procedure<a class="anchor" aria-label="anchor" href="#the-monte-carlo-style-cross-validation-procedure"></a></h2>


<p>Each hyperparameter setting is cross-validated by:</p><ol><li><p>Randomly corrupting <code>perc_test</code> percent of the entries in <code>D</code> as missing
(i.e. <code>NA</code> values), yielding <code>D_tilde</code>. Done via <code><a href="sim_na.html">sim_na()</a></code>.</p></li>
<li><p>Running the PCP function <code>pcp_fn</code> on <code>D_tilde</code>, yielding estimates <code>L</code>
and <code>S</code>.</p></li>
<li><p>Recording the relative recovery error of <code>L</code> compared with the input data
matrix <code>D</code> for <em>only those values that were imputed as missing during the
corruption step</em> (step 1 above). Mathematically, calculate:
\(||P_{\Omega^c}(D - L)||_F / ||P_{\Omega^c}(D)||_F\), where
\(P_{\Omega^c}\) selects only those entries where
<code>is.na(D_tilde) == TRUE</code>.</p></li>
<li><p>Repeating steps 1-3 for a total of <code>num_runs</code>-many times, where each "run"
has a unique random seed from <code>1</code> to <code>num_runs</code> associated with it.</p></li>
<li><p>Performance statistics can then be calculated for each "run", and then
summarized across all runs for average model performance statistics.</p></li>
</ol></div>
    <div class="section level2">
    <h2 id="best-practices-for-perc-test-and-num-runs">Best practices for <code>perc_test</code> and <code>num_runs</code><a class="anchor" aria-label="anchor" href="#best-practices-for-perc-test-and-num-runs"></a></h2>


<p>Experimentally, this grid search procedure retrieves the best performing
PCP parameter settings when <code>perc_test</code> is relatively low, e.g.
<code>perc_test = 0.05</code>, or 5%, and <code>num_runs</code> is relatively high, e.g.
<code>num_runs = 100</code>.</p>
<p>The larger <code>perc_test</code> is, the more the test set turns into a matrix
completion problem, rather than the desired matrix decomposition problem. To
better resemble the actual problem PCP will be faced with come inference
time, <code>perc_test</code> should therefore be kept relatively low.</p>
<p>Choosing a reasonable value for <code>num_runs</code> is dependent on the need to keep
<code>perc_test</code> relatively low. Ideally, a large enough <code>num_runs</code> is used so
that many (if not all) of the entries in <code>D</code> are likely to eventually be
tested. Note that since test set entries are chosen randomly for all runs <code>1</code>
through <code>num_runs</code>, in the pathologically worst case scenario, the same exact
test set could be drawn each time. In the best case scenario, a different
test set is obtained each run, providing balanced coverage of <code>D</code>. Viewed
another way, the smaller <code>num_runs</code> is, the more the results are susceptible
to overfitting to the relatively few selected test sets.</p>
    </div>
    <div class="section level2">
    <h2 id="interpretaion-of-results">Interpretaion of results<a class="anchor" aria-label="anchor" href="#interpretaion-of-results"></a></h2>


<p>Once the grid search of has been conducted, the optimal hyperparameters can
be chosen by examining the output statistics <code>summary_stats</code>. Below are a
few suggestions for how to interpret the <code>summary_stats</code> table:</p><ul><li><p>Generally speaking, the first thing a user will want to inspect is the
<code>rel_err</code> statistic, capturing the relative discrepancy between recovered
test sets and their original, observed (yet possibly noisy) values. Lower
<code>rel_err</code> means the PCP model was better able to recover the held-out test
set. So, in general, <strong>the best parameter settings are those with the
lowest <code>rel_err</code>.</strong> Having said this, it is important to remember that this
statistic should be taken with a grain of salt: Because no ground truth <code>L</code>
matrix exists, the <code>rel_err</code> measurement is forced to rely on the
comparison between the <em>noisy observed data</em> matrix <code>D</code> and the <em>estimated
low-rank model</em> <code>L</code>. So the <code>rel_err</code> metric is an "apples to oranges"
relative error. For data that is a priori expected to be subject to a
high degree of noise, it may actually be better to <em>discard</em>
parameter settings with <em>suspiciously low</em> <code>rel_err</code>s (in which
case the solution may be hallucinating an inaccurate low-rank structure
from the observed noise).</p></li>
<li><p>For grid searches using <code><a href="root_pcp.html">root_pcp()</a></code> as the PCP model, parameters that
fail to converge can be discarded. Generally, fewer <code><a href="root_pcp.html">root_pcp()</a></code> iterations
(<code>num_iter</code>) taken to reach convergence portend a more reliable / stable
solution. In rare cases, the user may need to increase <code><a href="root_pcp.html">root_pcp()</a></code>'s
<code>max_iter</code> argument to reach convergence. <code><a href="rrmc.html">rrmc()</a></code> does not report
convergence metadata, as its optimization scheme runs for a fixed
number of iterations.</p></li>
<li><p>Parameter settings with unreasonable sparsity or rank measurements
can also be discarded. Here, "unreasonable" means these reported metrics
flagrantly contradict prior assumptions, knowledge, or work. For instance,
most air pollution datasets contain a number of extreme exposure events, so
PCP solutions returning sparse <code>S</code> models with 100% sparsity have obviously
been regularized too heavily. Solutions with lower sparsities should be
preferred. Note that reported sparsity and rank measurements are <em>estimates
heavily dependent on the <code>thresh</code> set by the <code><a href="sparsity.html">sparsity()</a></code> &amp; <code><a href="matrix_rank.html">matrix_rank()</a></code>
functions</em>. E.g. it could be that the actual average matrix rank is much
higher or lower when a threshold that better takes into account the
relative scale of the singular values is used. Likewise for the sparsity
estimations. Also, recall that the given value for <code>perc_test</code> artifically
sets a sparsity floor, since those missing entries in the test set cannot
be recovered in the <code>S</code> matrix. E.g. if <code>perc_test = 0.05</code>, then no
parameter setting will have an estimated sparsity lower than 5%.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="sim_na.html">sim_na()</a></code>, <code><a href="sparsity.html">sparsity()</a></code>, <code><a href="matrix_rank.html">matrix_rank()</a></code>, <code><a href="get_pcp_defaults.html">get_pcp_defaults()</a></code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co">#### -------Simple simulated PCP problem-------####</span></span></span>
<span class="r-in"><span><span class="co"># First we will simulate a simple dataset with the sim_data() function.</span></span></span>
<span class="r-in"><span><span class="co"># The dataset will be a 100x10 matrix comprised of:</span></span></span>
<span class="r-in"><span><span class="co"># 1. A rank-3 component as the ground truth L matrix;</span></span></span>
<span class="r-in"><span><span class="co"># 2. A ground truth sparse component S w/outliers along the diagonal; and</span></span></span>
<span class="r-in"><span><span class="co"># 3. A dense Gaussian noise component</span></span></span>
<span class="r-in"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_data.html">sim_data</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co">#### -------Tiny grid search-------####</span></span></span>
<span class="r-in"><span><span class="co"># Here is a tiny grid search just to test the function quickly.</span></span></span>
<span class="r-in"><span><span class="co"># In practice we would recommend a larger grid search.</span></span></span>
<span class="r-in"><span><span class="co"># For examples of larger searches, see the vignettes.</span></span></span>
<span class="r-in"><span><span class="va">gs</span> <span class="op">&lt;-</span> <span class="fu">grid_search_cv</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data</span><span class="op">$</span><span class="va">D</span>,</span></span>
<span class="r-in"><span>  <span class="va">rrmc</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="st">"eta"</span> <span class="op">=</span> <span class="fl">0.35</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  r <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  num_runs <span class="op">=</span> <span class="fl">2</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Initializing grid search...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Beginning sequential grid search...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Start time: 2025-03-27 22:04:50.891155</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Grid search completed at time: 2025-03-27 22:04:51.451853</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Metrics calculations complete.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Grid search completed!</span>
<span class="r-in"><span><span class="va">gs</span><span class="op">$</span><span class="va">summary_stats</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #949494;"># A tibble: 3 × 7</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     eta     r rel_err L_rank S_sparsity iterations run_error_perc</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>      <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>      <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>         </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #BCBCBC;">1</span>  0.35     3   0.113      3      0.990        <span style="color: #BB0000;">NaN</span> 0%            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #BCBCBC;">2</span>  0.35     2   0.162      2      0.998        <span style="color: #BB0000;">NaN</span> 0%            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #BCBCBC;">3</span>  0.35     1   0.172      1      1            <span style="color: #BB0000;">NaN</span> 0%            </span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://lawrence-chillrud.github.io/" class="external-link">Lawrence G. Chillrud</a>, <a href="https://www.linkedin.com/in/jaime-benavides-72959356/" class="external-link">Jaime Benavides</a>, <a href="https://lizzy.codes/index.html" class="external-link">Elizabeth A. Gibson</a>, <a href="https://scholar.google.com/citations?user=LyLU8koAAAAJ&amp;hl=en" class="external-link">Junhui Zhang</a>, <a href="https://www.linkedin.com/in/jingkai-yan-a49a9516a/" class="external-link">Jingkai Yan</a>, <a href="https://www.columbia.edu/~jw2966/" class="external-link">John N. Wright</a>, <a href="https://jeffgoldsmith.com/" class="external-link">Jeff Goldsmith</a>, <a href="https://marianthi.github.io/makLAB.github.io/" class="external-link">Marianthi-Anna Kioumourtzoglou</a>, <a href="https://www.publichealth.columbia.edu/" class="external-link"><img src="https://www.publichealth.columbia.edu/sites/default/files/logo-mailman-blue-horizontal.svg?stefxf" width="240" alt=""></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

