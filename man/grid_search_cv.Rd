% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_search_cv.R
\name{grid_search_cv}
\alias{grid_search_cv}
\title{Cross-validated grid search of the parameters for Principle Component Pursuit (PCP).}
\usage{
grid_search_cv(
  mat,
  pcp_func,
  grid,
  scale_func = NULL,
  parallel_approach = "multisession",
  cores = parallel::detectCores(logical = F),
  perc_test = 0.05,
  runs = 100,
  conserve_memory = FALSE,
  verbose = TRUE,
  save_as = NULL,
  ...
)
}
\arguments{
\item{mat}{The data matrix to conduct the grid search on.}

\item{pcp_func}{The PCP function to use when grid searching. \emph{Note: the PCP function passed must be able to handle missing \code{NA} values.} For example: \code{root_pcp_na}.}

\item{grid}{A dataframe with dimension N x P containing the N-many settings of P-many parameters to try. \emph{The columns of \code{grid} should be named exactly as they are in the function
header of} \code{pcp_func}. For example, if \code{pcp_func = root_pcp_noncvx_na}, then the columns of \code{grid} should be named "lambda", "mu", and "r"
An optional additional column named "rel_err" can be included that contains the mean relative error recorded by that row's parameter setting, with those rows (settings) that have not been tried left as \code{NA}.
In this way, you can perform a grid search in which you already know the relative errors of some parameter settings, but would like to expand your knowledge of the unexplored parts of the grid further.}

\item{scale_func}{(Optional) The function used to scale the input \code{mat} by column. By default, \code{scale_func = NULL}, and no scaling is to be done at all.}

\item{parallel_approach}{(Optional) The computational approach used when conducting the gridsearch (to be passed on to the \code{future} package's \code{\link[future]{plan}} function). Must be one of: \code{"sequential", "multisession", "multicore"}. By default, \code{parallel_approach = "multisession"}, which does parallelization via sockets (in separate R sessions) and works on any operating system. If \code{parallel_approach = "sequential"} then the search will be conducted in serial. The option \code{parallel_approach = "multicore"} is not supported on Windows machines, nor in RStudio (must be run from the command line) but is faster than the \code{"multisession"} approach since it runs separate forked R processes.}

\item{cores}{(Optional) The number of cores to use when parallelizing the grid search. By default, \code{cores = parallel::detectCores(logical = F)}, which is the number of physical CPUs available on the machine.}

\item{perc_test}{(Optional) The fraction of entries of \code{mat} that will be randomly imputed as \code{NA} missing values (the test set). Can be anthing in the range \code{[0, 1)}. By default, \code{perc_test = 0.15}.}

\item{runs}{(Optional) The number of times to test a given parameter setting. By default, \code{runs = 1}.}

\item{conserve_memory}{(Optional) A logical indicating if you only care about the actual statistics of the gridsearch and would therefore like to conserve memory when running the gridsearch. If set to \code{TRUE}, then only statistics on the parameters tested will be returned. By default, \code{conserve_memory = FALSE}, in which case additional objects saving the outputs of all runs of \code{pcp_func} will also be returned.}

\item{verbose}{(Optional) A logical indicating if you would like verbose output displayed or not. By default, \code{verbose = TRUE}.}

\item{save_as}{(Optional) A character containing the root of the file path used to save the output to. Importantly, this should not end in any file extension, since this character will be used to save both the resulting \code{[save_as].rds} and {[save_as]_README.txt} files. By default, \code{save_as = NULL}, in which case the gridsearch is not saved to any file.}

\item{...}{\emph{Any parameters required by \code{pcp_func} that could not be specified in \code{grid}. Importantly, these parameters are therefore kept constant (not involved in the grid search). The best example is the \code{LOD} parameter for those PCP functions that require the \code{LOD} argument.}}
}
\value{
A list containing the following:
\describe{
   \item{\code{all_stats}}{A \code{data.frame} containing the statistics of every run comprising the grid search. These statistics include the parameter settings for the run, along with the \code{run} number (used as the seed in the corruption step outlined in step 1 of the \strong{Methods} section), the relative error for the run \code{rel_err}, the rank of the recovered L matrix \code{L_rank}, the sparsity of the recovered S matrix \code{S_sparsity}, the number of \code{iterations} PCP took to reach convergence, and the error status \code{run_error} of the PCP run (\code{NA} if no error, otherwise a character).}
   \item{\code{summary_stats}}{A \code{data.frame} containing a summary of the information in \code{all_stats}. Made to easily pass on to \code{\link{print_gs}}.}
   \item{\code{L_mats}}{A list containing all the L matrices returned from PCP throughout the gridsearch. Therefore, \code{length(L_mats) == nrow(all_stats)}. Row i in \code{all_stats} corresponds to \code{L_mats[[i]]}. Only returned when \code{conserve_memory = FALSE}.}
   \item{\code{S_mats}}{A list containing all the S matrices returned from PCP throughout the gridsearch. Therefore, \code{length(S_mats) == nrow(all_stats)}. Row i in \code{all_stats} corresponds to \code{S_mats[[i]]}. Only returned when \code{conserve_memory = FALSE}.}
   \item{\code{test_mats}}{A list of \code{length(runs)} containing all the corrupted test mats (and their masks) used throughout the gridsearch. Note: \code{all_stats$run[i]} corresponds to \code{test_mats[[i]]}. Only returned when \code{conserve_memory = FALSE}.}
   \item{\code{original_mat}}{The original data matrix \code{mat} after it was column scaled by \code{scale_func}. Only returned when \code{conserve_memory = FALSE}.}
   \item{\code{constant_params}}{A copy of the constant parameters that were originally passed to the gridsearch (for record keeping).}
}
}
\description{
\code{grid_search_cv} conducts a cross-validated grid search of the parameters for a given data matrix \code{mat}, PCP function \code{pcp_func}, and settings of parameters to search through \code{grid}. See the \strong{Methods} section below for more details.
}
\section{Methods}{

Each hyperparameter setting is cross-validated by:
\enumerate{
  \item Randomly corrupting \code{perc_test} percent of the entries in \code{mat} as missing (i.e. \code{NA} values), yielding \code{corrupted_mat}.
  Done via the \code{\link{corrupt_mat_randomly}} function.
  \item Running the PCP function (\code{pcp_func}) on \code{corrupted_mat}, giving \code{L_hat} and \code{S_hat}.
  \item Recording the relative recovery errors of \code{L_hat} compared with the input data matrix \code{mat} for only those values that were imputed as missing during the corruption step. Ie. \code{||P_OmegaCompliment(mat - L_hat)||_F / ||P_OmegaCompliment(mat)||_F}.
  \item Repeating steps 1-3 for a total of \code{runs} many times.
  \item Reporting the mean of the \code{runs}-many runs for each parameter setting.
}
}

\examples{

library(pcpr) # since we will be passing \code{grid_search_cv} a PCP function

# simulate a data matrix:

n <- 50
p <- 10
data <- sim_data(sim_seed = 1, nrow = n, ncol = p, rank = 3, sigma=0, add_sparse = FALSE)
mat <- data$M

# pick parameter settings of lambda and mu to try:

lambdas <- c(1/sqrt(n), 1.25/sqrt(n), 1.5/sqrt(n))
mus <- c(sqrt(p/2), sqrt(p/1.5), sqrt(p/1.25))
param_grid <- expand.grid(lambda = lambdas, mu = mus)

# run the grid search:

search_results <- grid_search_cv(mat, pcp_func = root_pcp_na, grid_df = param_grid, cores = 4, perc_b = 0.2, runs = 20, verbose = TRUE, save_as = NULL)

# visualize the output:

print_gs2(search_results$summary_stats)
}
\seealso{
Older versions of PCP's gridsearch (not recommended): \code{\link{grid_search_cv}}, \code{\link{random_search_cv}}, \code{\link{bayes_search_cv}}, and \code{\link{print_gs}}
}
